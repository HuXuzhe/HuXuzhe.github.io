<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CS231n笔记(1)]]></title>
    <url>%2F2018%2F11%2F06%2FCS231n%E7%AC%94%E8%AE%B0-1%2F</url>
    <content type="text"><![CDATA[写在前面 本文是并不是完全对于CS231n课程的全部翻译，只是作者对课程的一个总结的笔记记录。如有错误的地方，请指出并留言，作者十分感谢。 关注公众号：AI数据算法分析大家一起进步学习人工智能。 主要内容此篇内容主要讲CS231n课程内容，根据B站课程内容P4部分的笔记总结。 图像分类、数据驱动方法和流程 Nearest Neighbor分类器 CS231n P4课程—图像分类 图像分类课程开始于5:09左右，如果大家想直接进入课程的，可以直接跳到5分09秒开始。 如上图，图片分类是计算机视觉的核心任务。 目标：所谓图像分类，就是将已经做好了标签的图片进行分类，将一个个图片元素分为一个个集合。然后对于输入的图像，从分类标签集合中找出一个分类标签，最后把分类标签分配给该输入图像。 例子：如上图，计算机通过对图像进行分类，并生成集合，比如{cat,dog,pig,plane,..}，然后对输入的图像进行计算，得到在集合中标签的的概率，从而来预测图片属于哪个分类。 计算机中的图片： 计算机是如何识别图片的，当然是和我们识别图片的方法不一样。图像是由一个巨大的三维数组组成的，在上述图片的例子中。这张图片的分辨率是248$\times$400，就可以说这张图片的长度是248个像素，高有400个像素；并且这是一张彩色图片，因此有3个颜色通道，分别是红绿蓝，简称RGB。所以该图像总共有$248\times400\times3=297600$个数字。由于RBG三个三原色的强度范围都是0~255，其中0表示全黑，255就表示全白。 我们的目标和任务就是把这些上百万的数字变成一个简单的标签，用来预测输入的图片。如下图所示。 虽然是对于图片的简单的分类，对于我们来说，识别一只猫是非常简单的。但是对于计算机来说，还是有一定的困难，会遇到一定的问题。 下面列举了可能遇到的问题，取自于课程的内容。 视觉变化(Viewpoint variation)：同一个物体，摄像机可以从多个角度来展现。 大小变化(Scale variation)：物体可视的大小通常是会变化的。 形变(Deformation)：很多东西的形状并非一成不变的，会有很大的变化 遮挡(Occlusion)：目标物体有可能被一些杂物遮挡，有时候只有物体的一小部分，甚至就单单的几个像素点 光照条件(Illumination condition)：在像素层面上，光照的影响非常大 背景干扰(Background clutter)：物体可能混入背景之中，使其物体难以被辨认 类内差异(Intra-class variation)：一类物体的个体之间的外形差异很大，比如飞机，有客机，战斗机，隐形飞机，直升机等，都有自己的特征。 数据驱动方法数据驱动，其实就是给计算机很多数据，不停的“喂”食物。然后实现学习算法，让计算机学习到每个类的特征。 数据驱动方法的步骤： 收集图片以及标签的数据集，也称此数据集为训练集(train set) 使用机器学习来训练一个分类器 通过分类器来评估预测一张新的图片，把分类器预测的标签和图像真正的分类标签作对比 我们来看一看收集的数据集，如下图所示，只有4个分类的训练集。但在实际中，我们可能有上千分类，每个分类都有成千上万的图像。 Nearest Neighbor 分类器未完待续…..]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>CS231n笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理---实用工具(2)]]></title>
    <url>%2F2018%2F11%2F06%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7-2%2F</url>
    <content type="text"><![CDATA[写在前面继续来写实用工具，继续介绍纪元老师的三个实用工具。 内容工具四—–养成坏习惯法这个工具其实是一个理念。不怕坏习惯，就怕坏习惯失控。坏习惯占用了我们太多的时间和精力，所以我们需要控制坏习惯。 使用场景： 刷手机 看剧 速食 吸烟喝酒 ······ 具体方法： 为坏习惯安排出特定的时间安排出特定的时间专心刷手机，而其他的时间不玩手机 把坏习惯当做完成任务的奖励比如完成一个重要的报告，就可以奖励自己刷10分钟手机等，这样完成一个任务就有一个盼头，其实可以刺激我们更好的完成任务 控制剂量： 每天或每周安排出时间 监控自己是否过量 所有的这类的坏习惯，其中根本原因就是无聊。因为我们没事做，就自然而然就去想到坏习惯，因为坏习惯往往都是来消遣时间的。当我们工作很忙，专注度足够的时候，我们就不会去想坏习惯。 注意事项： 和平共处 练习停止 像培养好习惯一样对待 实用工具—–早起倒逼早睡法早起的话，之前用双闹钟法，我们是可以达到一定的目标的。但我们仍然不能早睡，是因为缺乏早睡的动力。 早睡的动力： 如果晚睡，就会影响第二天的精神状态 长期的晚睡会影响自己的身体健康 早起也是早睡的动力 截止日期倒逼： 在目标日期后绝不再做这件事。 当我们设定一个目标日期，这个目标日期并不是截止日期，这个目标日期之前是要做这事情，但是后目标日期之后绝不做这些日期。倒逼的方法，就是要远离这个舒适圈。 舒适圈： 做过的事情 熟悉的环境 熟悉的人 不用多花时间 很高把握达成 不用多花时间 做过的事 然后非舒适圈，有挑战、不安全，有紧张感、不确定性，我们并不想进入这个非舒适圈，但是我们的成长是不可能一直待在舒适圈，我们大部分都是因为突破非舒适圈而得到成长和进步，不断扩大的自己的舒适圈。 工具三—–具象法坚持自下而上的改变，从具体的行为而改变，并不是单纯的从观念认知去改变。 自上而下的改变：认知升级，是我们的思维和我们的观念上的改变，通过观念上的变化来促进我们的行动。 自下而上的改变： 是从行为入手，通过具体的行为，最直接的看到改变，能让我们得到小小的成就感，就更容易坚持下去，从而可以改变我们的观念。 时间管理并不是一个观念，而是一系列的具体的行为。]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理---实用工具(1)]]></title>
    <url>%2F2018%2F11%2F06%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7-%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[写在前面之前讲了如何进行自我习惯以及时间管理的养成，然后进行了场景答疑并且剖析问题，最后我们就来讲一讲时间管理的实用工具。 内容工具一—–双闹钟法使用场景 啊早上反复关闭闹钟继续睡 需要非常早起 培养早起习惯 帮助孩子按时起床 具体操作 Wake闹钟+Up闹钟 wake闹钟：声音轻柔、枕边，并且比up闹钟的定时提前5分钟 up闹钟：声音震撼，远方 为了不让up闹钟吵醒家人，所以当我们被wake闹钟提示下，我们必须起床去关掉up闹钟，就可以强制让我们自己走起，而不会继续让我们躺在床上。最好的在up闹钟旁边，放上一杯温水，来让我们更近一步提神。 为了让我们养成早起的习惯，每天坚持上双闹钟。不要轻易撤掉这个环境。 早起的禁忌：早起不知道为啥？ 我们需要提早把早起之后的事情准备好，为了防止我们没有事做而去睡回笼觉。 注意事项： up闹钟的音量要足够大 up闹钟必须本人亲自关 up闹钟不关就不要停止 up闹钟旁摆放接下来需要用到的物品 工具二—–环境创设法核心思想：就是改变环境，来提高我们的工作效率。 使用场景： 高度思考类创造类工作 需要提高自己的专注程度 使用方法： 如一样，我们把我们的环境分为5层。 外环境： 就是我们所处在的工作的大环境。如果我们较为安静的地方，更容易有专注度，所以首先我们可以改变我们的大环境。 工作环境： 聚焦的是我们眼前的桌面，就是我们的视觉范围之内，尽可能保持整洁明亮舒适，这样我们就可以更好的保持专注度。 点子环境： 电脑的桌面，竟可能的关掉即时通讯工具，关掉刺激性的提醒的工具，手机的话，我们可以切换成静音，甚至摆到视觉以外，来提高专注度。 内心环境： 我们可以通过呼吸放松法来改变，我们在专注的状态下保持自己的注意力，集中在我们呼吸上，通过呼吸来调节自己的心境，使我们平静，来提升自己的专注力。 任务环境： 我们如果遇到大块的艰巨的任务，很有可能逃避，不想面对，所以我们就需要把大任务分解成小任务，我们面对小任务就没有那么大的抗拒感；我们也可以把生活任务和工作任务穿插进行，让我们一直保持自己的心态和任务环境。 注意事项： 任何环境的改变都是有成本的 改变环境，应持续进行，一劳永逸 工具三—–预算控制法预算控制法适用于长期的任务。适用于完成一个大项目。 使用场景： 长期项目任务 目标明确 有截止日期 预算与计划过程 都要做什么事情 分别花费多长时间 总共花费多长时间 到截止日期前还有多长时间 平均每天需要投入多少时间 是否需要取舍 计划与监控 每天要确保完成任务的进度 如果有完不成的情况或者超额完成的情况，要对计划及时的调整以及重新规划 注意事项： 任务管理都是有成本的 不适合目标模糊的事项 不适合没有截止日期的任务 不适合短期的小任务]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理(22)]]></title>
    <url>%2F2018%2F10%2F30%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-22%2F</url>
    <content type="text"><![CDATA[写在前面场景答疑第十场，早起倒逼早睡真的靠谱么？ 内容问题案例主人公提问：老师，听了老师节目，里面有些方法很赞同，比如随手记，状态优先法这些，通过这些方法，确实感觉节省了很多时间。 但是有一个问题始终困扰主人公，主人公是夜猫子党，每天熬夜晚睡，所以第二天早上总也起不来。然后质疑早起倒逼早睡这个方法是否可行。 问题解析像“早起倒逼早睡”这句话，只要说出来，写出来，就可以被从各个角度去理解，断章取义是不可取的。任何的作者在说出这样一句话时，都有他初始的立场和目的，忽略这个源头而仅仅去探究这句话，很可能就是失去了对作者初心的理解。 不是要阐述早起和早睡的关系是什么，也没打算否定早睡对早起的影响作用，是在谈当一个人想要提升早睡的动力，避免晚间各种耗着不睡的情况时，可以把要求自己早起作为一种手段来使用，这种手段在心里和生理提升早睡的可能性。 当然，一定要警惕，当人们否定一个东西时，有时往往并未理解自己否定的东西，有时否定的是强加给作者的但作者并未要表达的意思，有时则是扩大化作者的意思然后加以否定。上述这些情况都可以通过学习批判思考并加以练习来避免。 总结关于学习，推荐大家都做行动派，避免做评论家。学习，尤其是致用类学习，目的是为了解决自身问题，改变自己，而不是为了 鉴赏什么。每个老师每位作者可能都从各自的角度提出一些解决问题的方案，角度可能不同，诠释方法可能不同，对于学习者而言，能够切实可行并且行之有效最为重要。早睡早起这件事对每个人来都意义非凡！！]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理(21)]]></title>
    <url>%2F2018%2F10%2F29%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-21%2F</url>
    <content type="text"><![CDATA[写在前面场景答疑第九课，自由职业者如何规划自己的时间？ 内容问题案例主人公是一名自由职业者。之前觉得可以安排自己每天做什么可以自己又自在的，可是发现没有朝九晚五的约束，没有各类指标逼迫，但主人公没有对自己的时间安排都不能进行合理规划，感觉很微妙，有些危机感。太忙了又觉得没有自由，自由了又觉得有些无聊，这个要怎么平衡呢？ 解决方法首先应该认清自由职业也是个职业，并非不给公司打工在家呆着就是自由职业，那只能叫待业。任何的职业，都有职业的需求，自由职业也不例外。自由职业，我们也可以称其为“自我雇佣”，简称“自雇”。你可能是你公司唯一的一名员工，你有责任有义务为你的组织制定业务目标，设置规章制度并遵守这些规则。 区分时间上的自由和时间上的任性，自由职业者的优势在于可以有选择的工作，并且可以按照自己的节奏选择最佳的策略去安排自己的时间，但这并不意味着随便、放纵自己，不约束自己。任由自己作为人类的劣根性和本能驱使来度过每一天，你很难成为优秀的自由职业者。 建立自己的作息规律，可以参考我在睡眠管理这节课中的方法，让自己保持一个良好稳定的工作状态。同时，对于你的每一天，应该有所规划，场景清单将会是一个对你而言非常有帮助的工具，安排出一天当中哪些时候是你的工作时间，哪些时候是用来处理个人事务，这会非常重要。人其实不怕忙碌，最怕不规律。 总结自由职业者并不自由，只是工作自由度大了，但是仍要工作，仍要出卖自己的技能和时间来换取收入，这不该成为你的终点。你自己的时间，不要停止学习，要不断优化自己的产品和服务，逐渐让它们可复制，可规模化，这应该成为你努力的方向。]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理(20)]]></title>
    <url>%2F2018%2F10%2F28%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-20%2F</url>
    <content type="text"><![CDATA[写在前面场景答疑第八个，关于如何高效利用上下班途中的时间？ 内容问题案例主人公是一名职场新手，初入职场杂事很多，每天都在忙碌，可是每天晚上睡前都会想今天白天做了什么？又忙又没有效率，真的是好迷茫！主人公每天花在通勤路上的时间早上和晚上加起来的时间大概是3个小时，之前都是听歌，看视频打发时间。 但是目前觉得不能这样下去，打算利用这段时间来学东西，所以想请教纪元老师该如何利用这段上班下班通勤时间？ 案例分析上下班通勤，最推荐的不是利用这段时间，而是减少这段时间。较长的通勤时间无异于慢性自杀。 为什么不推荐利用上下班的时间？ 长时间通勤将提高我们的压力水平 长时间通勤意味着我们的睡眠时间和锻炼时间少 长时间通勤时间和高胆固醇和高BMI值相关 上下班的路上我们通常是孤独的 长时间通勤导致我们和伴侣相处时间少 长时间通勤相当于减少了寿命，缩短了自己人生的长度 解决方法 考虑换工作或者搬到离公司近的地方，从而缩减上下班的距离 改变交通方式，选择更快捷的交通工具 错开高峰出行的策略避开拥堵，减少通勤时间 努力过上不用上班的生活(太难) 最佳的利用方式是锻炼身体和放松，我们要做的更多是放空大脑 其次，就是和家人、伴侣朋友多沟通感情，这些能做好就能抵消掉长时间通勤的一些危害 最后，才轮到读书、听课之类的事情呢]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理(19)]]></title>
    <url>%2F2018%2F10%2F27%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-19%2F</url>
    <content type="text"><![CDATA[写在前面场景答疑第九次，如何摆脱重度拖延症？ 内容问题案例主人公是一名工作两年的小员工，每次都是一晃到周末了，每次写报周报的时候，列了一下待办事宜，待办8件。有的任务已经拖了一周，由于工作性质的原因，基本每天都会有新的，临时性的，紧急处理的任务，似乎这也成为了一些拖延事情的借口，除了紧急任务之外，别的都是一拖再拖，每次都搞得焦头烂额并且焦虑，怎么样才能解决这个问题？如何摆脱重度拖延症呢？ 问题剖析纪元老师回答：”拖延症”这个词，是他比较反感的。并且他在他的书和课程里尽量去避免这个词，因为这是个推卸责任的词，就如同一个人感冒了，所以咳嗽打喷嚏就变得自然正常，给自己贴上拖延标签，自己的拖延行为就好像顺理成章的成了一种症状，而非因为个人的自我管理出了问题，这样的思考模式并不利于一个人成长。 解决方法做计划拖延的倾向是正常的，面对困难的，枯燥的，不情愿做的事情，我们自然而然的会选择逃避，往后拖，我们的失职在于没有为可能发生的拖延做预防性工作。所谓预防性工作就是做计划。 长远和短期的划分，分别介绍了做计划的方法，核心思想就是了解具体要做什么以及怎么做，然后对所要做的事情需要投入的时间精力进行评估和预测。 这个工作非常非常的重要，完成后，我们的感知就会发生改变化，我们就会更倾向于采取行动而非回避。 认知的改变任何人都会拖延，自律的人也拖延。拖延的近义词是推迟。它是一个动作，是处理任何一项时一个可能的选项，是一种高明的任务处理策略，表示当你面对一项任务时，暂时不去思考或暂时不去执行该任务。自律的人也会采用此策略，就如被家人告知该吃饭了，需要先把该段听完再去等等，这些都是拖延，所以拖延本身并不是一个贬义词，因此是否拖延并不是衡量一个人是否自律的标志，不同之处，自律的人拖延的理由不太一样。 总结自律者是不会因为以下理由而推迟该完成的任务： 好困难，好麻烦，没意思 想看个剧，想玩会儿游戏 拖延这个任务有可能就不需要做了 自律者在决定推迟一项任务时，会思考和标记这项任务更适合的执行时间，以便到时可以更有效的去完成它，而“拖延者”的大脑只是努力遗忘，忽视，不想去做这个任务。]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理(18)]]></title>
    <url>%2F2018%2F10%2F26%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-18%2F</url>
    <content type="text"><![CDATA[写在前面场景答疑第六天，为什么我们只坚持具体行为？【具象法】 内容问题案例主人公向纪老师提问，他不知道老师会不会有这种感受？生活中许多不喜欢的，但却不得不做的枯燥，重复的学习和工作任务，请问老师有什么好方法来高效率地完成这些任务。 问题剖析通常，高价值的事情，都伴随着挑战，痛苦甚至乏味，能否把这些事情做好，是使人和人之间产生巨大差异的一个重要原因。一件事情自己做不到，我们更可能将其归因为运气差或者意愿低，就如我一样，有时候会说要是和他一样努力，也可以达到那个程度，并不是能力的原因。但其实努力这件事就是个能力。 能够调动自己的情绪，能够集中注意力，能够把时间和精力用在相对枯燥、重复的学习上，这本身就是能力，不是个单单的意愿问题。 解决方法主动碎片化 时间碎了，你就要学会让自己适应它，训练自己用更短的时间进入做事状态，把大任务分解成若干个用时少的小任务。 就如之前课程所提到的随手记，待处理清单等方法，来解决大任务 两股力量可以推动要想更高效的完成这类事情，只有两股力量可以推动，外力逼迫和热情驱动。小时候，我们干的大部分事情都是在家长、老师这些外力驱使下完成的，大了之后，外力撤销，不努力不会立刻得到糟糕的情况，这时候我们就要给自己紧迫感，而不是没有了外力就停滞。当你将其作为你理想生活的铺路砖石，你就不会太在意过程的繁复，注意力就会落在自己不断的成长与进步上。]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理(17)]]></title>
    <url>%2F2018%2F10%2F25%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-17%2F</url>
    <content type="text"><![CDATA[写在前面来来来，场景答疑第五场，主题是：为什么说选对方向是最大的效率？ 内容案例主人公是一家医院的医生，每天都很忙碌，总有忙不完的事情，让其身心疲惫。 但是医生这个职业，要想干好，想要更多机会，就要不断的学习，去积累更多的知识和经验，将其转化为技能和才能。在学习纪元老师的时间管理后，养成了早睡早起还有一些烂开始的习惯，也成功运用了场景管理和三只青蛙法。但还是发现有一些习惯哪怕是烂开始都很坚持。还有工作中的碎片化时间都被用来调节情绪和放松了…… 所以如何去坚持一项没有回馈的事情呢？如何更有效的管理自己的碎片化时间呢？ 问题分析关于一个人的职业发展，可能在任何领域，都离不开持续不断的学习和积累，但在任何领域，又都不是只有一种发展路径。有些医生在体制外努力打拼，有些医生积极结交各行各业的朋友，而这些方式当中，都不乏小有成就的人。 一个人的发展，离不开周围环境的机遇，也离不开发挥自身的优势。 解决方法分析形式，评估自我所处地位 你是怎样的城市？一线、二线、还是三四线？ 你是在哪个级别的医院？三级、二级还是一级，甲等乙等还是丙？ 你在医院里优势怎么样的职级？ 这些大环境因素都决定了你的发展瓶颈和持续向上 发挥你的优势 每个人都有自己擅长的方面，把他们发挥出来就可以成为你的优势，当你的优势和你的环境相融，助力你的个人发展时，你的进步速度就会非常快。 你要不断发现和发挥你的优势，如果环境抑制了他们，你应该考虑变换你的环境，选择正确的方向 继续读书，学习深造在学习的这条路上前行，可以选择不同的“交通工具”，可以理解成“学习方法”。要相信，开车肯定比爬行更有效，也更可能坚持到终点。]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理(16)]]></title>
    <url>%2F2018%2F10%2F24%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-16%2F</url>
    <content type="text"><![CDATA[写在前面今天继续讲纪元老师的场景答疑，工作容易受到琐事打扰怎么办？ 内容问题案例主人公践行时间管理已经有一段时间了，但目前有一个很困惑的问题：主人公每天早上都会给自己安排好一天的任务及每项任务在什么时候做，但是总是有一些临时性的任务插进来打断。 比如某同事要帮个忙或者请教一个问题，又如领导过来安排一个工作。这些事情主人公又不能不拒绝，所以常常导致一天下来无法完成本来计划好的任务，然后晚上再梳理自己工作的时候就会很生气，请问主人公该怎么办？ 问题剖析当计划被“打乱”时你所遭遇的强烈挫折感，的确是件令人难受的事情，因为在时间管理中，我们努力想要从中获得一种掌控感，而突发事件却打破了我们原来对于自己的任务和时间的良好感知，给我们造成失控感。 这时候无所产生的不良情绪由于是一些紧急事件导致的，但是要相信，当你的时间管理水平逐渐提高，这种情况出现的频率以及给你造成的情绪困扰都会逐渐减轻，最后你能够掌控自己的时间。 解决方法 时间安排“八分饱”在之前的课程中所强调的“不使用严苛的时间表”，安排时间要“八分饱”，其实就是为了在时间上保持弹性，好应对突发事件。归根结底，是我们能否通过时间管理，把我们能掌控的那部分时间和任务，高效的安排和处理好，至于不能掌控的突发情况，这也只不过是常态而已。 提升自我价值，实现社会地位的晋升如果你掌控不了的事情比较多，有可能说明你现在的社会地位不高，时间的自由度较低。所以只能靠加倍努力，更充分地利用好所剩不多的自主时间，提升自我价值，实现社会地位的晋升。价值越高，地位越高，话语权越大，时间自由度就越大。 总结时间管理不是拿来救火的，而是“治未病”的。与其困扰于拖延导致的后遗症，不如多应用时间管理方法减少拖延的发生； 与其抱怨别人总是打乱自己的计划，不如多实践更有效靠谱的计划。 前者让自己颓废，后者则驱使自己进步。还是那么一句老话：智者支配时间，愚者受制于时间。]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学者Python入门以及环境搭建]]></title>
    <url>%2F2018%2F10%2F23%2F%E5%88%9D%E5%AD%A6%E8%80%85Python%E5%85%A5%E9%97%A8%E4%BB%A5%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[写在前面本章写的是适用于准备进入AI领域，开始着手准备学习Python的同学。希望能帮助到大家，欢迎关注“AI数据分析算法”公众号，加入我们的“AI Legends”—-AI 联盟。 内容适用对象：编程小白，准备安装Python进行学习的同学。 本文内容：步骤十分具体详细，有具体的图解参考。读完此篇，可以放心使用Python并且可以进行数据分析，我们并且给出了Pycharm的激活方式，以及打包好最新应用程序，只要按照步骤安装和环境搭建，就可以开始自己的Python之旅咯！！ 建议如果还没有开始Python工具下载的初学者，切记不要直接安装Python，推荐直接安装Anaconda搭建起来的科学环境，如果先安装Python，可能会导致Anaconda里面的Python的运行，Anaconda的科学环境使用方便，并且能直接与Pycharm对接，对于做项目来说也是非常方便的。因此，我们推荐安装Anaconda + Pycharm来学习Python，尤其是想将来学习数据分析的同学。 下载我们已经将Anaconda和Pycharm的安装程序保存在百度云，可以从公众号：AI数据分析算法，中回复“下载”从百度云中下载。下方有官方下载链接，但由于下载比较慢(墙外的请随意),推荐直接直接进入我们公众号进行操作。 Anaconda Pycharm 介绍我们按照下面的步骤来介绍 为什么是安装Anaconda + Pycharm 如何安装Anaconda 如何配置Anaconda环境 如何安装Pycharm 如何在Pycharm中配置Anaconda的包 如何使用Pycharm写出第一个程序 为什么是Anaconda + Pycharm？Anaconda是一个基于Python的数据处理和科学计算平台，它已经内置了许多非常有用的第三方库，装上Anaconda，就相当于把Python和一些如Numpy、Pandas、Scrip、Matplotlib等常用的库自动安装好了，使得安装比常规python安装要容易。如果没有安装Anaconda,而是安装了Python，那么还需要pip install一个一个安装 各种库，安装起来比较痛苦，还需要考虑兼容性。而且Anaconda里面的notebook还可以方便做笔记，markdown输出，对于公式的输入是尤其方便的。因此建议直接安装推荐直接使用Anaconda。 优秀的编译译器相当于编程语言的“word”，这里使用一个python编译器的word——Pycharm。原因是功能比较强大，调试可以设断点，最主要的是有很多人使用，因而初学者在跟着视频教程学习Python时也比较方便。这也是我推荐Pycharm的理由。 如何安装Anaconda按照下图下载，勾选3.7版本，2.X版本请忽略，因为现在都用3.X版本，后面深度学习只能跑3.X版本的Python。 接下来会弹出对话框，请填写邮箱地址和和主要作用，你可以选择填写，也可以直接打叉。 双击下载好的exe文件，点击Next——&gt; 点击 I Agree——&gt;直接点击Next 如图所示，修改完保存位置继续点击Next进入下一步 如上图一样，两个都打勾，然后安装等待即可。 安装好Anaconda后，重新打开命令行窗口(快捷键:windows键+R)，输入cmd，即可进入命令行窗口。 如图 所示，进入Anaconda环境然后直接输入 “conda list”，即可查看相关的包(package).常用的有numpy、scipy等 初次安装一般是比较老的，所以需要输入“conda update –all”命令，来更新所有的包。如说是需要安装包的话，例如想安装matplotlib，直接输入“conda matplotlib”即可安装，具体操作，可以百度或知乎搜索。如下图操作。 就可以进入anaconda，安装notebook，就可以使用python，开始你的第一句python程序。 如何安装Pycharm安装程序(社区版和专业版)都打包到百度云盘里面，在公众号：AI数据分析算法，回复“下载”，从网盘下载。直接点击“Download”即可。Pycharm有两种主要版本：Community和Professional，其中社区版本是免费的，专业版需要激活，激活可以直接百度搜查方法。 安装方法：和普通安装一样，改变安装路径，注意下图打勾处，再点击安装等待即可。 安装完成后，打开pycharm，需要几分钟等待(等待各个包载入)，但是运行时后非常流畅不会卡顿，请放心。 如何在Pycharm中配置Anaconda的包这一步，非常简单，按照以下链接过程配置即可。 在Pycharm中配置Anaconda的包 与Anaconda中的python连接完成，就可以开始创建第一个python程序。 ###如何使用Pycharm写出第一个程序 选择File—-&gt;New Project —-&gt;Pure Python(如下图可修改保存路径)—–&gt;creat(创建) 创建Python文件，按照下放截图操作即可。右键选择新建—-&gt;Python File 创建完成，会出现下面画面，输入Python文件名，不用加py的后缀，系统会自动加后缀。 开始第一个代码程序的开始我们以”Hello World”开始。键入print(“Hello World”)，切记全部需要半角符号，全角是会报错的。公众号也会陆续提供并发布python基础入门的相关资料和教程。关注【公众号：AI数据算法分析】，打开AI 世界的打门。 输出完程序，按照下图所示，在界面上有个小三角，但是是灰色的，所以首次运行需要右键点击py文件弹出对话框，选择运行即可。 运行完后，底部的控制界面就会出现运行结果“Hello World”。 到此安装配置全部结束，你可以开始你的Python的学习之旅了。 #####一些关于Anaconda的相关链接，以及Pycharm专业版激活链接(仅供参考)： Anaconda多环境版本以及基本操作 notebook的使用方法 Pycharm专业版激活 注：社区版的功能足够使用，下载社区免费版即可。 公众号也会陆续提供并发布python基础入门的相关资料和教程。 关注【公众号：AI数据算法分析】，打开AI 世界的打门。]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理(15)]]></title>
    <url>%2F2018%2F10%2F23%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-15%2F</url>
    <content type="text"><![CDATA[写在前面继续场景答疑，长期自律的人真的不累吗？关于这个问题，纪元老师给我讲述了【高效休息法】。让我们将时间管理养成活动，而不是把自己逼到一个巅峰，那样是会很累的！ 内容案例有人提问：他发现有很多学霸/精英每天学习/工作几十个小时，但是只睡六七个小时，所以他真的很好奇他们都是怎么避免疲劳的。再加上纪元老师每天都是4点起床，这样真的不累么？ 提问这就算平时最巅峰的状态，也顶多一天学习七八个小时，并且后期几乎精疲力尽，无法继续，第二天也很疲惫，很久缓不过来。所以提出：“怎么样长期维持这种状态(长期自律不累么?)”。 分析在此之前纪元老师澄清了几件事： 不是每天四点起床 也会很累，也会疲劳 每天学习/工作几十小时的叫工作狂，每天也只有晨间和上午工作，下午和晚间几乎不工作 从不坚持自己的巅峰状态，维持自己的常态 自律者使用方法，养成习惯 关于几个问题，进行了分别的解析并分享： 关于四点起床这件事四点起床只是个人习惯，在这里并不推荐任何人像老师那样4点起床，而且每天的睡眠与苏醒时间也不是固定的。我们应该正确看待困倦与休息的关系，合理调整自己的精力状况。我们应该享受休息。 会工作的人一定会休息困和疲劳是身体的信号，人不可能避免疲劳，但是在疲劳的时候，我们应该适当的休息，保证自己的状态在一定水平之上。自律者和常人的区别在于，他们每天都有目的的行动数量远于常人，较少用于自责，纠结，焦虑，患得患失等负面情绪上。一个自律者的一天要么是在工作，要么就是在休息。 活质量而不是活长度时间管理的目标是为了提高效率不是延长时间，关注于工作，学习的时长是没有意义的。用拖延时间去应对工作，通常会导致低效率，这是一种不需要学习就会的方式，没有质量可言的。 不打鸡血(对于我来说是重点，哈哈)自律者无需天天打鸡血，默默的坚持，不如轰轰烈烈的搞几个大事件。人们喜欢展示自己某一次令人感叹的成绩，让自己的努力变为常态。 自律是一种生活方式要成为一个自律者，不能仅仅靠”方法”，只有真正的“做到”才最有价值。使用方法、养成习惯，真正开始实践课程中所提供的方法，才是合理的。]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理(14)]]></title>
    <url>%2F2018%2F10%2F23%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-14%2F</url>
    <content type="text"><![CDATA[写在前面继续纪元老师的场景答疑，这次是对于在校大学生的答疑问题，因为时间的分散，从而不知道如何安排并管理自己的时间。高中的时间都是被老师课程安排好，但是大学确实不一样，可能上午一节下午一节，中间的时间不知道该如何，有的就白白的浪费，从而一学期下来，觉得时间都浪费了没有珍惜。 内容问题剖析上大学之前无论是时间还是目标都是安排好的，时间很规律，目标也很单一，而到了大学，目标突然散了，时间上的自由度也变大了。 自由以自律为基础，中小学时代没有教给学生自律，一直是他律状态，所以多数学生都没有自律的能力，到了大学，就很容易懒散、涣散。 解决方法 大学生应丰富体验： 多去尝试，拓展大量丰富的体验，并从中获得一种叫做学习能力的东西(例如打工，创业，跨专业上课等等) 去做你想做的，去做你没有做过的事情 大学时间碎，你该跟着碎 时间碎了，你就要学会让你自己适应它，训练自己用更短的时间进入做事状态，把大任务分解成若干个用时少的小任务 借鉴之前课程中提到的随手记、待处理清单、蛋糕切分法等内容 价值、伴侣、成长回想在10岁的时候开始积累，20岁就会有质的飞跃；同样我们趁着大学，为30岁的自己做积累，也同样会有质的飞越，不要一直回顾过去。 提升自己的能力，为自己增值(弄清楚自己的独特性，提升自己的硬实力) 要开始在未来伴侣这件事情上花功夫，学会与人相处，与人建立亲密关系、与人交流和沟通及化解冲突 保持每天进步一点点，如：大量的读书、听课、向他人求教等，然后去实践 总结这是纪元老师给大学生的肺腑之前。 接下来的十年，是你人生最宝贵的十年，是奠定基础的 十年，未来，沦为囚徒困在苟且还是化作苍鹰飞向诗和远方，就看这十年了，所以得好好的管理自己的时间，不要在和高中一样“他律”，而且成为“自律”。]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理(13)]]></title>
    <url>%2F2018%2F10%2F21%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-13%2F</url>
    <content type="text"><![CDATA[写在前面之前，我们都谈了关于好习惯的养成，坏习惯如何戒掉，长期任务与短期任务如何制定并且有步骤，通过具体化行为来一步步完成，通过小红花法来奖励自己并做好记录，来查看近期完成的情况。这次，我们通过场景答疑来提升自己，提高自己的时间效率，也可以说是工作效率。今天讲的就是，团队领导应如何管理使得员工不累，效率翻倍。 内容案例本次讲的女主角是一家公司的创始人，每天忙碌，交给属下办的事情总是不放心，所以在发布任务之前，把解决问题的方案和思路都告诉下属，觉得下属如果按照自己的方法去做，到时候需要花费太多时间来返工。所以自己压力大，工作效率也不高。 分析这是一个典型的管理者效能的问题，一般，由于业务能力强被提拔上来当管理者，都会遇到此类的问题。要意识到这个和时间管理一样，都是有方法可以遵循的。 管理者的工作重点与业务人员不同，核心人物是要从团队成员中创造价值，尽可能把工作分配给他人。之所以任务下属的工作做不好，是因为管理者没有对“好”进行定义，将权衡标准与目标告知下属，实现任务目标。 解决方案放下身段，做好管理者角色，选择合适的管理方式，保证任务执行的过程及结果。 激励型管理：紧盯结果核心人物是去勾勒任务的结果给团队成员，然后让他们去充分发挥自己的能力。当一个人可以自己去选择实现目标的方式时，他会更有动力去完成任务。当他们碰到难题或情绪低落时，给予支持与鼓励。 ###教育型管理：紧抓过程 重点是让你团队的成员学习和成长，在这个过程中允许他们犯错，传授给他们业务能力，讲解思考和做事的步骤，让他们学会正确的过程，并及时纠正、指导。 监控型管理：关注两者意味着从过程到结果你都要管理，如果是选择这种方式，你会付出很多，并且确保这次过后，你的团队成员能够有长足的进步。 总结管理方法的选择需要在了解你的团队的基础上因人而异 对于内向、专家式的团队成员，最好使用激励型管理，他们有能力达成有挑战性的目标 对于外向、通吃型的团队成员，最好选择教育型管理，因为他们享受和别人的互动、配合来完成目标 不同的团队成员有着不同的性格，不同的优势，推荐大家通过《现在，发挥你的优势》这本书对团队进行测评。 切记，不要一味的抱怨！！]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理(12)]]></title>
    <url>%2F2018%2F10%2F20%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-12%2F</url>
    <content type="text"><![CDATA[写在前面上次我们讲了短期目标和任务，这次我们讲长期任务，这也是最具有挑战的任务。长期任务，通常需要几周、数月甚至几年的时间，为其制定计划是个颇具挑战的任务。比如说，对于学生的我们来说，备考就是一个典型的长期任务。而且期限往往是几个月甚至几年之后。但是，多数人真正意识到自己应该认真做计划并全力以赴备考的时候，大部分时间已经流逝过去了，浪费了。所以这段时间我们就要对其进行规划。 这次我们就可以学习到通过怎么样的方式可以将长期任务落实规划，从而实现自己的目标。 内容案例：某人在距离高考就只剩几个月的时候，感到无法专心复习，效率不高，成绩又不理想，无法执行自己的制定的计划。 分析： 长期任务，涉及到目标和计划，通常目标是相对清楚的，但是计划不明确。我们就要学习，如果明确自己的计划。 解决方法预算控制法知道自己要做的事情以及花费的时间，才能进一步制定计划，在这种情况下执行任务，每天自己做的好坏、是否完成计划清晰可见。每天全力以赴完成每天的任务。 行为促进法针对高考复习做的具体行为操作： 小红花法，观察和记录每天复习任务的完成情况 检查可用时间及环境，可以变换到学习效率更高的环境复习 整理复习资料，碎片化的拆开着 状态好时复习挑战较大的材料，状态不佳时学习容易的材料 找到一起执行任务的小伙伴，相互比较，相互督促 我们可以根据上面的方法来延伸并应用到我们自己的长期目标上。 九大核心思想 顺应人性：承认自己有极限 倒逼：预计行动花费时间来提供执行效率 过程：正确过程得到正确结果 概率：提高时间管理方法在工作和生活中应用的概率 具体化：只有具体的问题才能引导人找到落地的方法去解决 行为：关注具体怎么做 切分：细化、细化再细化 碎片化：主动碎片化 环境：走到进步的环境里去完成自己的目标 总结但我们把目标具象为自己和社会创造财富时，我们就可能有了自己人生的主轴。 时间围绕着整个主轴管理起来更有效果。望我们在自律、自由的道路上越走越顺利。]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理辅助工具推荐]]></title>
    <url>%2F2018%2F10%2F19%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[写在前面在提高效率的时候，我们无法观测到我们的效率，也无法每天得知我们是否有提高，而且时间管理本来就是一件需要长时间的管理才有可能提高，或者看到自己的改变。我们就可以通过用工具来对我们平时的花费时间进行检测，数据图表化，辅助我们提高，每天看到进步，增加我们的自信心，从而坚持达到质的进步。 内容目前来说，推荐2~3种，自己觉得比较好用的PC端工具，移动端在store里面一搜，特别多，这里就不详细推荐了。 第一个：滴答清单这个滴答清单是我用来纪录待处理清单使用的，移动端也可以下载，一个账号能PC和移动同步操作，值得一提的是可以把家人或者同事加入group，来一起完成任务并且check。以下是我的部分截图。 下载链接 第二个：rescue time这个软件，不需要我们手动记录时间开支，就可以获得时间开支报表，他只会在电脑的后台运行。 注册登录 下载Rescue Time软件 bingo！ 接下来我们可以在任意时刻查看我们的时间报表，能够清楚的看到我们在使用电脑的时候大部分时间花费在什么地方，然后再做出修改。注意：这个软件苹果手机移动端是没有的，但是iphone的系统只要升级到了ios12就可以直接查看移动端，这里给出的网址是PC端的rescue time。 下载链接 如上图，只需要点击Recuse Time.com Dshboard， 即可以查看各种图标。 第三个：梦畅闹钟梦畅闹钟，我是用来给自己任务定时，以及健康提醒等。能够在桌面放置一个时钟，看到一秒一秒的时间流逝，用来提高我们的紧迫感。下载: 我是直接在360软件管理里面搜索的，或者直接百度搜索即可下载。 第四个：自律帮 下载：只有移动端才有，安卓和ios系统皆有，电脑只有网页版本。如图所示，不仅有项目，可以进行随手记；还有习惯，每天的早起早睡，喝水的次数都有相应的次数打卡，来观察我们每天完成的次数。在使用前请认真阅读此应用的使用方法，阅读完成后再继续使用。方法说明在初入应用时就有，直接阅读即可。今天发才发现，一块新大陆。也是纪元老师所设计并发行的，结合多重功能，就如app描述一样，All In One。很赞！！！ 总结本来以为这个总结15分钟就可以搞定，结果延长了2个5分钟，还是没有预估好时间，个人也是刚刚开始进行时间管理，因为觉得这个三个应用非常实用，所以推荐给大家，希望能够一起努力，对自己的时间越来越能把握。智者支配时间，愚者受制于时间。]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
        <tag>工具推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理(11)]]></title>
    <url>%2F2018%2F10%2F19%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-11%2F</url>
    <content type="text"><![CDATA[写在前面我们学习了那么多的方法，都是为了 提高做事的效率，能够专注和轻松的执行任务，但是很多人都觉得自己容易分心、执行力差，但事实上，多数人都是计划能力弱。 做事时候要想专注于行动，那么前期的准备工作是必不可少的。那么，我们应该如何提高效率呢，乃至用20的精力完成80的任务呢？我们在这节将要讲环境创设法和帕金森法，帮我们在做事之前消灭所有的分心因素，进而达到心无旁骛的状态，提高做事效率。 内容很多事并不是智力问题，是专心不专心的事。 导致我们分心的也许不是我们的性格缺陷，而是分心之物和分心之心。这两点都可以通过事先的准备来排除，从而让我们在做事的时候也能够一样的专心，心无旁骛。 解决方法环境创设法是指通过改变我们的外部环境从而达到减少分心。所以说，智者支配环境，愚者受制于环境。 六大步骤第一步，改变我们最大的外环境：你身处的地方，比如看书等去图书馆或者自习室，比较安静容易专注的地方，而且不费心。(首先你去了图书馆或者自习室就证明你不懒！！) 第二步，改变我们身处的小环境：留下必备物品，并且保持桌面的整洁，对会使我们分心的物品断舍离。(养成物归原处的好习惯，花时间找东西的时间累积起来有可能够你旅游的勒 ) 第三步，整理电脑环境，手机的正确摆放位置是屏幕朝下，或者摆在笔记本后面。但书中上不可缺少的是时钟。电脑上的时钟可以定时报时，为的是让我们培养出时间感知，时刻提醒我 们时间再流逝，提高我们的紧迫感。 第四步：调息静心，通过有规律的深呼吸使自己的心率降低，内心平静，内除杂念 第五步，帕金森法，改变我们对所要执行的任务的感知，创造住专注的条件。我们可以通过前面讲的预演来预估所花费的时间，当我们知道当前任务需要25分钟完成，我们就更有可能花费25分钟甚至之内完成，这就是创造专注条件。接下里在这里说明一下帕金森法： 所谓帕金森法，就是改变我们队所要执行任务的感知，创造专注的条件。想让先开始启动的工作效率高，则要尽快使自己进入”心流”状态，达到这种状态需要一些条件：有明确目标；有及时反馈；我们对生活有掌控感。 第六步，在执行的过程中主动碎片化，把任务的和放松统统打碎，这里就可以灵活运用前面讲到的是切蛋糕法。 总结效率达人，并非在执行时，他们有什么神技或者与常人不同，他们的详细的前期准备往往都是你看不到的。 不是他们不容易分心，而是他们提前通过改变大环境、工作环境和电脑环境避开了分心的因素，通过调息调节了自己的心境，通过对任务的管理和计划实现碎片化的结果。 我们是没有办法在长达数小时的时间里一直保持高效率，如果一直保持那肯定不是人类，而且这个过程非常煎熬，需要忍住很多想做的事情不能做，白白消耗了意志力。与此努力强逼自己这样，不如干脆把任务和放松统统打碎。完成40分钟任务，可以休息几分钟，松弛交替，能更好的提高工作效率。 环境对人影响作用是巨大的，要不然孟母何必三迁呢。所以还是那句话：智者支配环境，愚者受制于环境。]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理(10)]]></title>
    <url>%2F2018%2F10%2F18%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-10%2F</url>
    <content type="text"><![CDATA[写在前面之前我们都是讲如何养成好习惯，如何做计划，但是如果存在坏习惯，也会让我们的效率大打折扣，所以今天我们在这里可以学习到如何戒掉一个坏习惯，主要是我们管不住自己。 其实身边很多人都有坏习惯，还有各种上瘾停不下来，尤其是手机瘾，看剧瘾，游戏瘾等，一旦开始就整小时正小时的消磨时间，兴奋过后，自己又觉得荒废，闭门思过几日，就又重蹈覆辙。 时间要是被大量的被娱乐，坏习惯和各种不良的思维消耗掉，我们就很难腾出更多时间来处理我们清单的任务，所以，戒掉坏习惯对我们时间管理也是非常重要的。 内容分析为什么我们有的时候明知道有事情要做，但是就被电视剧、美剧、游戏等消耗时间，以至于每天应该处理的事情不能完成。 心理学家发现，大部分人的坏习惯与压力相关，我们要做的不是和自己较劲，而是和自己的坏习惯和谐相处，从而一点一点的将坏习惯戒掉。 解决办法：利用做记录的方法来提醒自己，就拿看电视剧来举个例子。我们用铜牌、银牌、金牌将记录区分开。 铜牌：忍不住看剧之后，在日历上打叉银牌：在看剧之前打叉金牌：在看剧之前打完叉，却又忍住了没看，画勾。一周只要一个勾就能得到金牌。 看剧做记录就是管理自己的毅力。戒掉坏习惯不是需要当断则断，而是需要一个还蛮适应的过程。 戒掉坏习惯的四个阶段 管控期 养成坏习惯 制造障碍 彻底戒掉坏习惯 管控期通过记录监控自己的坏习惯需要做的努力较小。做记录是引导自己对自己进行观察，当人在被观察的情况下，我们会做相应的调整自己的行为。但我们关注自己的行为时候，自我行为通过会被改变成自己想要做的行为。做记录的最佳时间是发生行为之前，做记录相当于一个停顿，就因为有这个停顿，有可能就很好的控制了我们自己。 养成坏习惯给自己固定的放松时间，放松可以作为一个坚持戒掉坏习惯的鼓励，将自己戒掉坏习惯的负担减轻。 制造障碍增加一些新的小习惯，使这些小习惯给你的坏习惯造成障碍。比如想要抽烟的人，就不带打火机。 彻底戒掉坏习惯前三个阶段的努力是最后成功的铺垫，给自己一个时机，将坏习惯一举歼灭。戒掉坏习惯是循序渐进完成的，用良好的习惯去补足那些坏习惯。 总结首先，坚持长时间的自我记录，很认真的记录自己每天不良行为是否发生了，并且做到可以在不良行为发生之前进行记录。 其次，观察自己的不良行为是否形成了规律，并且在我们的控制范围内不会轻易放纵。 第三阶段，通过给自己制造麻烦，进一步减少了不良行为的发生 这时候，当我们已经完成适应了新的状态，并做好准备，才可以尝试完全消除坏习惯。 戒掉坏习惯不是一上来就彻底不做某件事，因为这样会造成一种“真空”，人一定会去想办法填补这个真空的，而填补的内容通常都是最简单最容易上手的事情。旧的坏习惯一定会是首选。就哪减肥来说，大多数人在减肥前告诉自己以后都不能大吃大喝了，所以常常以一段大吃大喝作为开始，这样就会体会到一种“亏欠感”，导致很难坚持下去，甚至某一天又大吃大喝，然后就又回到了坏习惯。]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理(9)]]></title>
    <url>%2F2018%2F10%2F17%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-9%2F</url>
    <content type="text"><![CDATA[写在前面一提到时间管理，我们都会想到去做计划，而一提到计划，就会去谈年计划，月计划再分解到周计划，日计划。 我们普遍以为自己知道什么是计划，并且向当然的就认为自己会做计划，只是计划做的好坏不同。但是事实上，几乎所有人的认识都是错误的。我们将在这节课告诉我们什么才是真正的计划，并聚焦于短期任务的计划给我们讲解具体的操作方法，而后面我们还将会讲解如何对长期的任务做计划。 内容案例以及分析一般人做计划，比如我，背英语单词，写英语阅读笔记，看书……等，这并不是计划。 百度中计划所解释： 在管理学中，计划具有两重含义，其一是计划工作，是指根据对组织外部环境与内部条件的分析，提出在未来一定时期内要达到的组织目标以及实现目标的方案途径。其二是计划形式，是指用文字和指标等形式所表述的组织以及组织内不同部门和不同成员，在未来一定时期内关于行动方向、内容和方式安排的管理事件。 计划是用来实现某个目标的步骤列表，其中包含了时间和所需资源。计划的作用应该是促进任务目标的高校完成。计划应是一系列的步骤，指明了完成某一任务的具体方案和程序。 我们一般认为事件+时间点就是计划，其实并不然。 所以计划，一定是缜密思考的过程。 区分简单任务与复杂任务 简单任务不需要过分思考 复杂的知识创造性工作任务需要认真做计划，计划是个思考过程。 解决办法自然计划法：定义成果 ———&gt; 头脑风暴 ———&gt; 组织整理 ———-&gt; 心理预演 定义结果确认任务完成的程度，不同结果预期决定了不同的投入程度，防止过多的投入与无效的工作内容 头脑风暴 不做评价和筛选，任何想法和素材都可以进行堆砌，不要考虑是否能被用上 只想关于打算做什么的，避免陷入具体实施的细节中 组织整理将上一步找到的要点做整理排序，确认事情的先后顺序与实施要点，形成大纲。 将任务在头脑中模拟执行 当步骤完成预演后，任务会更加顺畅和高校 在预演过程中可发现步骤设计的不合理处，完善步骤内容 总结计划是用来促进任务执行的步骤 计划的过程是思考的一个过程，并不是事件+时间 运用自然计划法，你可以通过四个贴合你自然思考模式的步骤把有难度的任务分解、落实，行程有效的计划。 自然计划法：定义结果，头脑风暴，组织整理，心理预演 总之，计划一定要有任务执行，并不是简简单单写几个字，要不然很容易开小差，只有事情分成一步步，才会进而完成一个大计划。]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理(8)]]></title>
    <url>%2F2018%2F10%2F16%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-8%2F</url>
    <content type="text"><![CDATA[写在前面前面我们学习如何管理任务和习惯，并且化为了一个个行动记入了待清理清单。经常有人说，每天都很忙，但一天到头缺又不知道自己都忙了什么，就好像在说：“抽屉里东西很多，却不知道都有什么。”这一小节，我们将学习到如何安排日程的相关要领，帮助我们过上井井有条的每一天，并从中获得成就感。 内容有些人从来不安排自己的时间管理，或者还有另外一个极端用极其严厉的时间来控制，最终失败受挫，严格的日程表最多坚持2天，最后变为一张废纸。 所以日程表的安排不需要过分严苛，要合理计划掌控时间，想法和做法难免会冲突，完全按照时间表行动难免出现问题。 解决方法场景清单 用场景当做收纳盒来规划每一天，而不是都用严格的时间来控制自己，场景不受严格的时间点束缚，具有弹性。如果时间比较严苛，不弹性，容易体验到自己失败，这样就非常容易放弃自己的安排。 充分考虑自身状态和所处环境限制，更有利于安排合适的事情。 确定一个场景，把适合的事情放进去作为安排，划分若千个场景，形成一张场景清单。 八分饱原则所谓八分饱，就意味着你不要把这个场景安排满。在执行活动时，应该有“仪式感”。 简单方式 先设置一个场景，先把这个场景安排好做好，再逐渐的增多更多的场景。 三只青蛙法 三只青蛙法 青蛙，代表一天当中重要的(当天完不成非常糟糕的事情，或者是与别人的约会等可能影响他人或者自己的事情)，并且期望自己全力以赴在当天完成的事情。 三只青蛙，就是只写下三件当天重要的事情，推荐先自我要求一个任务作为当天最终的任务，如果持续一段时间执行的很好，再逐渐变二变三。 方法综合三只青蛙和场景结合法结合使用，规划出一个专门的场景，来完成重要的事情。 三只青蛙和“成就日志”相结合，帮助自己从行动中获得成就感，增加自信。 总结大部分人都是从未认真安排过自己的每一天，一旦心血来潮，又会使用非常非常严苛的方法来规划，结果轻易就受挫放弃。 换一个角度，如果我们每天都能把压在我们心中最大的石头搞定，把最胖的那只青蛙吃掉，把和自己最关键的承诺兑现，把最重要的事情完成，那么，你的时间利用也很不错了，而且这一天过得一定是有成就感的。 所以我们要制定自己的时间规划，有弹性的调整自己，这样的手段就是管理，我们要好好利用管理，让自己每天尽可能变得充实起来。]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理(7)]]></title>
    <url>%2F2018%2F10%2F15%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-7%2F</url>
    <content type="text"><![CDATA[写在前面锻炼身体可以增加我们生命的长度和质量，但在这件事上，我们投入的时间比较少，尤其对于长期加班，工作学习繁重的人，“没时间”就成了万能的挡箭牌。 其实健身这件事不需要那么多时间，既不需要你煞有介事的跑到健身房送钱办卡，也不需要你一个小时半个小时苦哈哈的跑步，那些听上去高大上的事情往往是最难坚持的，你也不需要为了证明什么而来折磨自己。 其实吧，只要方法得当，仅仅利用碎片化的时间，付出极小的努力，就能达到健身的标准，而且还有更有趣呢~~ 内容案例以及分析某加班狗，平时很少欲奴东，本以为去健身房就可以达到健身减肥的效果。但是由于时间比较少，以及健身不规律，最终放弃健身。 开始健身的原则：花费时间少，投入精力少，哪都可以做 形成“小习惯”：一次可能做几十个，一天做一次或更多。每天都只需要利用各种碎片化的时间即可，每种动作锻炼不同的部位，一天穿插若干个不同的动作。 解决方法碎片化时间健身的三大高招，结合健身，主动碎片化，健康银行。健身是一个持续的东西，只有持续的健身才能更有效果。 方法—结合健身把健身动作和你在做的事情结合起来，边做事情边完成健身。 其强大之处在于无需要额外付出时间，就可以基本达到健身的目的。 方法—主动碎片化讲究劳逸结合，每当完成了一个富有挑战的任务后，或一个长时间的任务做完一个小阶段后，你可以找几个小事情做一做，当作放松，还能增加成就感，也匹配了“状态优先法。” 方法—健康银行结合健身项目，应用小红花做记录，还可增加一个 更有趣的玩法，设定每一个健身动作所对应的金额，比如一个俯卧撑0.1元，一个瑜伽1元等，这样的健身相当于往自己的健康银行存钱。 总结选择碎片化健身动作的时候注意，为了能在最短的时间达到最佳的运动效果，同时表面运动伤害，你应该选择你目前身体水平能承受的运动量。个人可以按照自己的身体情况选择相应的锻炼动作，切勿好大喜功。 状态好则做困难事情，状态一般则找一些简单琐碎的事情做，碎片化的健身动作就属于简单琐碎的事情。 我们吃饭点菜，讲究荤素单配，我们做事情也一样，应该要有劳逸结合。对于我们来说，无论是结合式的健身好碍事主动碎片化健身，都是一样需要新培养的习惯。]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理(6)]]></title>
    <url>%2F2018%2F10%2F14%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-6%2F</url>
    <content type="text"><![CDATA[写在前面前面我们学了随手记和待处理清单，可是有的时候我们任务需要的时间长且必须有重要的，就比如我来说，我每个学习的发表乃至最终的毕业论文，贯穿了我整个研究生生涯。如果在最后期限的时候完成，那样不仅非常的焦急，而且会完成的很糟糕，会有影响毕业等问题。所以这节我们会学习到如何切分大型任务和长远任务的方法。 内容分析在我们的待处理清单上，就如上所说，有很多一些时间长的时间盘踞在上面，72小时内也没做，但也不该被删掉，这样的事情通常对我们有长远的意义。 我们总是倾向于先做有趣的、简单的、新奇的和急迫的事情。但是富有意义和价值的事情却通常都是颇具挑战的长期任务，过程不但困难重重，还乏味无趣，而且只有在临近截止日期时才会显得更加急迫。 因此，我们需要学习一些时间管理方法来更有效的处理好这些长远的要事。 对于眼前急迫的事情和长远重要的事情，我们有完全不同的两种思维： 一种像士兵，时刻保持着紧张状态，快速应对突发情况 一种则像哨兵，站在更高处，观察远方环顾四周，发现一切可能性 要想让我们能够管理好长远的重要的事情，必须将你思维的哨兵模式激活（非常重要） 方法想要很好的达到哨兵模式，我们需要有三个条件。 你的大脑必须有能发现重要事情的能力 给重要的事情以公平角逐的机会 有快速开始行动的方法 随手记我们可以通过随手记，来完成哨兵的侦查工作，让大脑有发现的事情的能力，并且给重要的事情以公平角逐的机会。任何时候，有想到可做的事情，可以立刻把它纳入到你的清单里。 待处理清单随后记形成的待处理清单在大脑以外，大脑无法否定和压抑它忽略它，当我们每天看着待处理清单来做事情，大脑就必须关照那些长远的事情。这样，待处理清单上面的事情就可以和紧急的事情都有机会获得均等的机会。 蛋糕切分法我们长远的目标往往是个非常大的目标，但是大目标也不能在短时间内完成，我们可能就会一拖再拖，拖到快要到截止日期，就会开始慌乱。就比如我，每次发表都拖在一个礼拜内完成，是一个非常值得反思的问题。 蛋糕切分法，就是要一个一个的切出下一步行动。面对下一步行动要比面对整件事轻松很多，我们就更愿意开始行动起来。当我们的注意力从庞大的，无从下手的想法集中到容易操作的行动上来时，我们就能减少拖延的发生。 总结随手记，待处理清单，蛋糕切分法，72小时原则和状态优先法要好好结合使用。 时间管理不是自我束缚，更像是心想事成的秘诀。]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理(5)]]></title>
    <url>%2F2018%2F10%2F13%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-5%2F</url>
    <content type="text"><![CDATA[写在前面这节我们将学习如何摆脱晚睡陋习。我们常常再看会儿这个，玩一会儿那个，干一会儿那个。虽然我们大家都知道早睡早起身体好，晚上经常晚于11点睡觉会严重影响自己的身体健康，记忆力会差，情绪会糟糕，皮肤还会不好。我们将学习到三种早睡方法，分别是早起倒逼法，沐浴自控法以及晚间二分法。更重要的是我们能够更加利用起来实现大家的自我提升。 内容分析我们想要晚上学习知识提升自己，但总是忍不住去看剧，玩手机，十二点还不睡觉。早睡的三大动力恰好与早起能匹配。一旦陷入了诱惑，我们就会给自己找理由，总会跟自己妥协。 早睡和早起这两件事是分不开的，要早睡，先早起。早睡需要生理调节和心理动力的，必须靠要求自己早起才能制造出二者。 方法早起倒逼法通常只要保持三天早起，晚上的开始睡觉时间大多都会提前，因为经过三天的早起，我们的身体已经很累了。 并且开始早起后，可以以十五分钟为单位，这样压力不会大而且比较容易适应，将自己的睡觉时间慢慢提前，提升自己的睡眠质量。 这里注意一下，白天的话尽量小睡（保持在半个小时之内），不能大睡，要不然会影响晚上早睡的。 沐浴自控法以洗澡这件事作为每天睡前仪式的开始。因为沐浴，自然而然让我们原来电子产品，所以可以好好利用洗澡这个过程来脱离手机对我们的诱惑。 睡眠专家指出，睡眠大约1~1.5小时洗澡可以帮助我们放松并提升体温，而1小时候的体温回落，可以使我们更容易入睡，并且睡的更香。手机、电脑等工具尽量在睡前不用，如果我们想要玩手机电脑等，尽量在睡觉前去使用，以洗澡作为分界线。 晚间二分法以洗澡作为分界线，将晚上划分为两个部分。 第一部分，洗澡前。可以进行健身，聊天等轻松的活动，注意不要超过规定的洗澡时间。 第二部分，洗澡后到睡觉。可以读书学习，尽量选择自己感兴趣的事情。思考明天要做的事情，为良好睡眠提供平静的情绪。（大约一小时，为入睡做好准备，不要被电子设备打扰。读书的内容的选择，不要特别高大上的，也不要特别刺激的，高大上的比如背单词，这样比较枯燥，就很可能去玩手机；特别刺激的话，比如小说，这样就会让我们停不下来，更加的睡不着以及晚睡。）其他的话，可以做好明天的准备工作，比如整理书包，衣服穿着，以及明天早晨早餐的食材。 切记，根据自己的睡觉时间定好洗澡的时间。 总结首先，起点是要求自己早起，通过早起制造自己生理节律上的变化和心理上的起床动力。 然后，我们需要根据自己的睡觉时间，确定好自己的洗澡时间，以洗澡为分界线，安排自己的时间，并把洗澡当成是晚间睡前最重要的一个仪式。 以洗澡为界，划分晚间为两个时间段，前一个时间段可以娱乐休闲运动睡觉以及高强度的学习，后一个时间段用来读书学习准备第二天，按这样的方式把晚间利用起来。]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理(4)]]></title>
    <url>%2F2018%2F10%2F12%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-4%2F</url>
    <content type="text"><![CDATA[写在前面前面三章通过要事管理可以把短期任务集中管理起来；通过早期创造了整块的自主时间；通过习惯养成巩固了自己的好习惯。这章讲述碎片管理——如何高效利用碎片时间。将掌握如何把浪费的时间利用起来的方法。 内容分析工作和生活都是应付状态，自己想做的事情也是随意想想又随意放在一旁，大部分时间刷手机自己也并不介意。害怕遇见糟糕的自己，也害怕遇见最棒的自己。 认为时间管理的方法不合适自己。其实哪儿来的适不适合呢？这就好像一个人要学武功，却非说跑步、站桩、练拳之类不适合自己，在他们看来，也许不费吹灰之力一掌把别人打飞才是他们觉得唯一合适的。 工具安卓手机用户：Rescue Time软件 作用：记录手机和电脑上各种软件的使用时间，并自动按照工作、娱乐、学习等分门别类，每天会生成一张报表来展示你的时间使用情况。 苹果用户：并不用按照老师所说的，只要升级为IOS12即可查看，各个app使用的时间，非常直观，比如我就是社交最多。 方法待处理清单结合好工具，接下来就是要好好利用好待处理清单这一个要事清单。 写下你所有要做的事情，尤其是要事，并且随时想到事情随时更新。待处理清单应该成为我们的行动指南。 我们需要主动安排事情，而不是等到迫在眉睫的时候才去处理事情，这样就会导致我们感觉特别忙特别焦急而且压力大，如果没有合理的安排事情，一闲下来我们自然就会觉得无聊没事，找刺激且浪费时间。当我们使用待处理清单来处理事情，我们时间就被分为两个部分，完成清单的时间和其他时间。先完成清单时间，再好好利用其他时间。 写在后面提升时间利用率我们都应该做的事情，一共三方面： 第一，我们可以使用自动时间记录工具来追踪你的电子设备使用情况，从而掌握自己目前的效率 第二，必须按照带处理清单来执行每天的任务 第三，了解每天执行清单任务所花费的时间。将更多的待办事项随时填写到待处理清单中，进一步扩大时间利用。 时间是你最宝贝的资源，越是富有的人越是这样觉得，逐渐把自己逝去的时间补回来，你就会看到自己巨大的改变，加油！]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理(3)]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-3%2F</url>
    <content type="text"><![CDATA[写在前面上一节我们学会了如何早起，早起既是一种非常立竿见影的时间管理方法，同时也是一种习惯。和早起一样，我们总觉得这是自己的意志力薄弱，其实，多数人开始培养一个习惯都不自觉的使用了错误的方法，期望过高，太过严苛，也就注定失败。为了养成一个良好的习惯，我们这节将讲解学习如何[如何坚持和养成好习惯]。从”烂开始”，”具象法”和”小红花法”。 主要内容##分析 以上图片可能是大多数人对于目标或者做出改变时候的走入的误区，其实三分钟热度每个人都是，意志力强的可能时间更久，但是这并不是缺点，只要找对象应的方法，利用这三分钟热度，是可以养成自己的好习惯的。 方法小红花针对每个习惯打卡，当天做到就打勾，能够直观地看到自己完成，是养成任何习惯的基础 制作习惯记录卡。 制作每行七个格子（代表一周七天）的表格，表格无论是纸质档还是电子档都应该放置于快捷位置，可以让我们轻松的找到并且查看。 具象法(非常重要)通过这个方法，可以知道是否完成并且达到了标准，什么时候才能奖励，需要非常清晰的衡量标准。具象法就是把目标具体形象化，大部分人写出目标就是每天阅读，每天减肥，但是并没有具体到如何阅读，如何减肥，以至于目标不明确不清晰，导致最后的失败。 用具象法定义要培养的习惯： 将每个习惯进行拆解和量化，有清晰明确的衡量目标 使用具体形象法回答这样一个问题：“我做出了一个什么样的行为就能代表我今天坚持了这个习惯？” 找出具体行为后还得找出实现该行为的步骤，而不是口头告诉自己，要利用好三分钟热度让自己行动起来 因为有的时候一个习惯里面包含了多个习惯，比如减肥，里面有减脂，增肌多种方法，减肥是一个目标一个结果，我们需要用多个具体行动来完成。 烂开始所谓烂开始，开始一项习惯前两周以最低的标准要求自己 两周的目的：为了把小红花法用起来，对习惯进行持续观察和记录 作用：保证三分钟热度后仍有较大可能性坚持下来 比如，每天阅读30分钟，烂开始则是读了就行；每天背20 个单词，烂开始就是背了1个就行。 神经学家塔利说过，“我们倾向于高估自己生活中发生好事的几率，低估坏事发生的几率。”开始一个习惯的时候，我们总是想的很好，在没开始行动的之前，我们感知不到其中的具体困难，然而“烂开始”的最低标准保证了“三分钟热度”退却后仍然有较大的机会坚持下去，倘若开始时候用力太猛，就容易难坚持下去。 好习惯可以从一个或者两个习惯开始养成，慢慢后习惯再增加来养成，不要一口气就下猛药，这样可能坚持一两天就坚持不下去了。 在习惯养成的道路上走得慢一些，走得远一些。]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理(2)]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-2%2F</url>
    <content type="text"><![CDATA[写在前面这里讲的是睡眠管理：如何养成早起习惯！早起，是最养生和搞笑的时间管理方法。但是真要坚持早起，却又难住了很多人。就比如我，曾经参加过早起活动，最后还是以失败告终。不过这部分，我们将学习到无痛起床的技能，帮助我们轻松实现早起并且真正坚持下来。我们也将学习到三个工具：双闹钟法，五分钟清醒术，三条命坚持。 案例 9点上班，一般设在7:30的闹钟，但是因为赖床一直拖到8点，甚至8点之后，结果匆匆忙忙赶路，乃至迟到。 为了寻求改变，参加早起打卡活动，最终将早起成为了负担，这样反而造成了更大的压力。 分析大部分认为起床是因为某种原因或者基因，有部分人也觉得自己因为晚上熬夜工作而让自己晚起，而不是一种习惯。(个人认为起床是一种习惯。) 开始打算早起是采用“决心+毅力”的方式，这种方式很难维持长久，交押金打卡更是给自己一个压力一种绑架，效果反而更加不好。 不过这里提出的，三无裸起：无备，无利，无命。 正确的早起打卡方式绝对不能靠“决心+毅力”，因为这样只能让少部分人硬逼着自己早起，反而越来越觉得累且不想早起。 这里讲的是“周目标+睡前准备”，本人也打算跟着老师试一试这种方法早起，望有效果！ 方法有备：准备好闹钟和水 有利：安排好你期待的事情做 有命：别指望每天都能做到 双闹钟法准备好两个闹钟(暂且命名为wake和up) Wake闹钟的时间定在你期望起床时间的3~5分钟，声音要轻柔，就放在你的枕边，只要它能够唤醒你就足够。(这里推荐一个app，叫作【蜗牛睡眠】) UP闹钟的时间应设置在你期望起床的时间，声音能够大到可以影响到他人，且置于手接触不到的地方。 这样当wake闹钟响后必须下床关掉up闹钟，为了防止影响到他人，下床关掉闹钟这一步是早起最重要的一步。 五分钟清醒术 身体传递的疲倦感，这样会导致我们有接着睡的想法(可通过五分钟清醒术消除) 未安排起床后值得期待坐的事情（事先安排） 五分钟清醒术： 喝一杯白开水（头天晚上置于up的闹钟旁） 开灯，洗漱，稍微运动都可以帮助我们唤醒身体，当身体的困倦感消失，我们就不会再去睡回笼觉，这里需要注意的是，我们要有期待的事情，要不然也容易返回继续睡觉。 这里提到的安排事情，希望能够安排一些有趣的，简单轻松的事情(头天晚上没有看完的电视剧，或者没有做完的事情)去做，而不是比较难达成的事情(跑步，背单词以及有挑战性的任务)。合理的安排能够提高我们早期的习惯，如果是习惯以后，可以增加期待事情的难度。 三条命坚持每天早起不应该当做目标，早起应该只设定周目标。 非要较劲每天都同一个时间点起床，这是自虐，来源于人天生自我折磨的倾向。人们总会用理想化的“应该”来要求自己，认为一个习惯每天都一样才叫习惯。这其实是徒增自己的压力，导致早起失败。 周目标：一周中有几天按照期望时间起床。 刚开始训练早起习惯的时候，推荐设定轴目标为四天，意味着有三天可以不用早起。早起只有失误，并没有失败。当我们把早起设为一个希望期待的事情或者一个理想，这样哪怕没有按时起床，也只是被认作一个失误，如果感觉失败的话就反而越来越觉得没有自信，最后早起失败。 写在后面想要真正做到早起并坚持，请做好三件事。 有备：准备好闹钟和水 有利：安排好你期待的事情做 有命：别傻傻的要求自己每天都做到 如果想要早起并获得更多时间的不妨一试，用来更好的提升自己并养成一个习惯。]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理(1)]]></title>
    <url>%2F2018%2F10%2F09%2F%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-1%2F</url>
    <content type="text"><![CDATA[时间管理第一课笔记如何用清单管理要事写在前面我们先来了解下“时间管理四象限”。按照重要性和紧急性两个指标把事情归纳为四类：重要紧急，重要不紧急，不重要紧急以及不重要不紧急。其实就是“要事优先做”，以免变的更加紧急。 但是真正行动起来的时候却发现：越重要的事情我们似乎越是拖着不愿意做，即变的越来越重要越来越紧急，最后就是刚刚好完成，乃至完成不了。戳痛泪点，我就是典型的这样，觉得时间会很多，时间也足够做完，想想还是比较可怕的。 分析“时间管理四象限”其实时间管理四象限并不能真正管理好要事，因为有的时候任务的重要性以及紧急程度是难以区分的，我们也无法按照排列好的任务顺序去执行，而且我们在列清单的时候，所谓的紧急的事情都是任务快要的期限的时候才觉得比较紧急，并非事情的重要或紧急。 解决方法高效处理“要事”的三大步骤：(举例为采核桃的步骤) 1.采摘：随时把核桃摘到框里 2.筛选：时常把手伸入筐对核桃进行筛选，品种以及质量不好的可以扔掉 3.品尝：筐里剩下的核桃，现在是想吃哪个就吃哪个 接下里，为了能够完成这三大步骤，讲述了”四大工具”： 工具一：随手记： 列清单应该随意记，而不是说特意找个时间来对事情的重要紧急程度来列清单，如果是这样，那列在清单里面的事情大部分都是非常紧急的事情，反而会忽略掉其他的重要的事情。 因此，每一天任何时候，只要你想到有件事情需要可能应该做的，就应该立刻纳入到清单里面。 工具二：待处理清单： 待处理清单就是”核桃筐”,并不是“待行动清单”。意味着写下来的事情不一定都是要做的事情。 所以我们需要时常去看待处理清单，并且思考每一件事并做出筛选。 工具三：72小时法则 如何筛选待处理清单： 1.逐项思考每一件你随手记下的事情 2.问自己今天、明天、后天是否打算花时间做这件事 3.如果答案是“否”，立刻删掉 4.如果需要做，就想一想都要做一些什么 不要过多浪费脑细胞去考虑事情的重要性，只考虑72小时之内是否要打算做某件事，这样能迫使自己觉得某件事是重要的 工具四：状态优先法(看心情) 用最适合的状态做最适合的事情： 如果自己现在状态好，可以挑有难度的事情 如果意识到状态不佳，就可以去找清单上简单上手的事情做一做，获得成就感，使状态回升 如果在不好的状态去强迫自己做有难度的事情，这样有可能事情完成不好或者失败，给我们自己徒增失落感和打击自信，状态则会越来越差。所以是合适的状态做合适的事。 写在后面希望自己能在学习完后有一次突破，对时间的利用率提高，接下来每课都会写自我总结，对课程有更好的把握并学习！]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[精读西瓜书(四)]]></title>
    <url>%2F2018%2F09%2F22%2F%E7%B2%BE%E8%AF%BB%E8%A5%BF%E7%93%9C%E4%B9%A6-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[写在前面继续西瓜书第二章内容，这篇内容以比较检验，偏差与方差为主，即将结束西瓜书第二章内容。 知识点归纳 比较检验 有了实验评估方法和性能度量，就能对学习器的性能进行评估比较。 但是怎么来做这个比较？ 实际上，机器学习中性能比较是比较复杂的，这里面主要涉及到三个重要因素。 1、希望比较的是泛化性能，但实际获得的是测试集上的性能，两者对比结果可能未必相同 2、测试集上的性能与测试集本身的选择有很大关系，即便是相同的测试集，测试样例不同，测试结果也会有不同 3、学习算法本身就有一定的随机性，即便相同的参数、相同的测试集，运行多次，结果也会有不同 因此，统计假设检验(hypothesis test)为我们进行学习器性能比较提供了重要依据。 假设检验为了便于讨论，本篇默认 以错误率为性能度量，用$\epsilon$表示。 比较检验的重要方法是统计假设检验。我们先来链接一下何为假设检验，若想详细了解，请自行学习并参考《概率论与数理统计》浙江大学[第四版]。下面简单的解释一下假设检验。 在总体的分布函数完全未知或只知其形式，但不知其参数的情况，为了推断总体的某些未知特性，提出某些关于总体的假设。我们要根据样本对所提出的假设作出是接受，还是拒绝的决策。假设检验是作出这一决策的过程。 假设检验四步走： 1、条件：满足条件（总体的分布函数完全未知或已知其形式，但不知其参数） 2、目标：推断总体的某位未知特性为目标 3、方法：提出某些关于总体的假设 4、行动：根据样本对所提出的假设作出是接受还是拒绝的决策 假设检验在机器学习的【比较检验】中是如何应用的，接下来来说明解释。 假设检验中的“假设”是对学习器泛化错误率分布的某种判断或猜想。 1、条件： 现实任务中，我们并不知道学习器的泛化错误率$\epsilon$，只能获知其测试错误率$\hat{\epsilon}$.泛化错误率与测试错误率未必相同，但直观上，二者接近性比较大。因此，可根据测试错误率估推出泛化错误率的分布。 2、目标： “若在测试集上观察到学习器A比B好，则A的泛化性能是否在统计意义上优于B，以及这个结论的把握有多大。”这便是总体的未知性。 3、方法： 以书中的例子为例，“$\epsilon = \epsilon_0$”，将泛化错误率假设为某数值$\epsilon_0$。 4、行动： 通过显著度$\alpha$来判断做出假设该被接受还是拒绝。 举例说明： 测试错误率：$\hat{\epsilon}$ 泛化错误率：$\epsilon$ 测试样本数：$m$ 误分类样本数：$m^\prime$]]></content>
      <categories>
        <category>机器学习</category>
        <category>精读西瓜书</category>
      </categories>
      <tags>
        <tag>模型评估与选择</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[精读西瓜书(三)]]></title>
    <url>%2F2018%2F09%2F19%2F%E7%B2%BE%E8%AF%BB%E8%A5%BF%E7%93%9C%E4%B9%A6-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[写在前面这里接精读西瓜书二内容，仍然讲的是模型的评估与选择，主要是性能度量。 知识点归纳性能度量先复习一下，机器学习理想的目标。 通过评估学习器的泛化误差，选出泛化误差最小的学习器。 上一节，通过不同的评估方法来选出最终的模型，但是对于学习器的泛化能力进行评估，仅仅评估方法是不够的，还需要有衡量模型泛化能力的评价标准，这就是性能度量(performance measure)。 【性能度量(performance measure)】：衡量模型泛化能力的评价标准 性能度量反映了任务需要，在对比不同模型的能力时，使用不同的性能度量往往会导致不同的评价结果。因此，什么样的学习器是好的，不仅仅取决于算法和数据，还决定于任务需求。 在预测任务中，$y_i$是示例$x_i$的真实标记，要评估学习器$f$的性能，需要把学习器预测结果$f(x)$与真实标记$y$进行比较。 因为有标记，所以讨论的是监督性学习。 回归任务均方误差【均方误差(mean squared error)】:回归任务最常用的性能度量。$$E(f;D) = \frac{1}{m} \sum_{i=1}^m (f(x_i)-y_i)^2$$可知，均方误差是m个离散样本的方差的平均数 但对于数据分布$D$和概率密度函数$p(\cdot)$，均方误差可描述为：$$E(f;D)=\int_{x \sim D}(f(x)-y)^2p(x)dx$$可以看出，此时样本可以看做非离散样本而是连续样本。 分类任务错误率与精度这是分类任务中最常用的两种性能度量，既适用于二分类任务，也适用于多分类任务。 错误率:分类错误的样本占总样本的比例 精度：分类正确的样本总样本的比例 【错误率公式】：$$E(f;D)=\frac{1}{m} \sum_{i=1}^m \mathbb{I}(f(x_i)\ne y_i)$$其中$$ \mathbb{I} (\cdot)$$为指示函数(indicator function)，真为1，假为0。常用于次数(满足某一断言或条件)的统计 错误率是m个离散样本的指示函数和的平均数 【精度公式】:$$\begin{align}acc(f;D) &amp; =\frac{1}{m}\sum_{i=1}^m \mathbb{I}(f(x_i)=y_i) \&amp; = 1-E(f;D) \\end{align}$$精度和错误率相同，也是m个离散样本的指示函数和的平均数，但是两个的指示函数不同。 但是，对于数据分布$D$和概率密度函数$p(\cdot)$，错误率与精度可分别描述为：$$E(f;D)=\int_{x \sim D}\mathbb{I}(f(x) \neq y)p(x)dx$$ $$\begin{align}acc(f;D) &amp;=\int_{x \sim D}\mathbb{I}(f(x) = y)p(x)dx \&amp; = 1-E(f;D)\end{align}$$ 可了解到，此时的样本可以看做费离散样本，也就是连续样本。 性能度量方法： 通常，错误率低、精度高的模型性能好；反之模型性能差。错误率与精度反应的是分类任务模型判断正确与否的能力。 查准率、查全率与F1错误率和精准率虽然常用，但不能满足所有的需求。当任务需求不是要判断有样本被判别正确与否的时候，而是关注正例以及反例的查出的准确率时，就需要使用其他的性能度量。 在二分类问题中，可根据其真实类别与学习器预测类别的组合划分为真正例(true positive)、假正例(false positive)、真反例(true negative)、假反例(false negative)，分别简称TP、FP、TN、FN，样例总数 = TP + FP + TN + FN。分类结果的“混淆矩阵(confusion matrix)”。 举例： 好西瓜判断成好西瓜，判断正确①【TP】；好西瓜判断成坏西瓜，判断错误②【TN】 坏西瓜判断成好西瓜，判断错误③【FP】；坏西瓜判断成坏西瓜，判断正确④【FN】 其中，①和④都是判断正确，②和③都是判断错误。错误率和精度是①和④、②和③的综合判断，只有判断正确与否的概念，但是没有正例与反例的区别，所以引入查准率【precision】与查全率【recall】。 【查准率】：【真正例样本数】与【预测结果是正例的样本数】的比值 【查全率】：【真正例样本数】与【真实情况是正例的样本数】的比值 查准率是挑出的好瓜里面，有多少是真的好瓜。如果希望选出的瓜中好瓜比例高的话，则可只挑选最有把握的瓜，但这样会难免会漏掉不少好瓜，查准率高了但查全率就会降低。 查全率是挑出来的真的好瓜，占总共好瓜个数的多少。希望将好瓜极可能多地挑出来，则可通过增加选瓜的数量来实现，如果所有西瓜都选上，那么所有的好瓜也必然都被选上，这样查准率就会降低。 一般来说，查准率高时，查全率偏低；查全率高，查准率偏低。通过只在一些简单任务中，查准率和查全率都偏高。 性能度量的方法：1.直接观察数值；2.建立P-R曲线 下面讲P-R曲线图，即以查准率为纵轴，查全率为横轴作图，就可以得到查准率-查全率曲线，简称“P-R曲线”。 值得注意的是，同一个模型，在同一个正例判断标准下，得到的查准率和查全率只有一个，也就是说，在图中应该是只有一个点，而不是一条曲线。 P-R图直观地显示出学习器在样本总体上的查全率、查准率。 可是如何来比较以及判断哪个学习器更优呢？ 当没有曲线交叉曲线的时候：外侧学习器性能优于内侧学习器，比如学习器B是优于学习器C 当曲线有交叉的时候： 方法一：比较P-R曲线下的面积大小，但是这个值不太容易估算。 方法二：设计了一些综合考虑查准率、查全率的性能度量。平衡点(Break-Even Point，简称BEP)就是这样一个度量，它是“查准率=查全率”时的取值。基于平衡点的比较，平衡点在外侧的曲线优于内测的，比如学习器A是优于学习器B 方法三：比较常用的是F1度量，F1的来能给的一般形式是$F_\beta$$$F1 = \frac{2\times P \times R}{P+R} = \frac{2 \times TP}{样例总数+TP-TN}$$ F1是基于查准率与查全率的调和平均(harmonic mean)定义的：$$\frac{1}{F1}=\frac{1}{2} \cdot (\frac{1}{P}+\frac{1}{R})$$$F_\beta$则是加权调和平均：$$\frac{1}{F_\beta}=\frac{1}{1+\beta^2} \cdot (\frac{1}{P}+\frac{\beta^2}{R})$$调和平均更重视较小值。其中$\beta &gt; 0$度量了查全率对查准率的相对重要性。$\beta = 1$为标准的F1，若大于1，查全率有更大影响；小于1，查准率有更大影响。 以上是一个二分类混淆矩阵的查全率和查准率的判断。 但实际情况中，有多个二分类混淆矩阵。当需要考虑估计算法的全局性能时，希望在N个二分类混淆集镇上综合考察查准率和查全率。有两种方法来解决。 方法1：“宏”：先在各混淆矩阵上分别计算出查准率和查全率，再计算平均值，得到宏查准率(macro-P)、宏查全率(macro-R)、宏F1(macro-F1) 方法2：“微”：先将各混淆矩阵的对应元素进行平均，得到TP、FP、TN、FN的平均值，再基于这些平均值计算出微查准率(micro-P)、微查全(micro-R)率以及微F1(micro-F1)的值。 ROC与AUCROC曲线图是通过对测试样本设置不同的阈值并与测试值进行比较，划分出正例与反例。再计算出两个重要量的值，分别以它们为横、纵坐标作图，就得到“ROC曲线”。与P-R不同的是，P-R图逐个将样本作为正例，而ROC图是逐次与阈值进行比较后划分正例。ROC曲线的纵轴是“真正例率(True Positive Rate,简称TPR)，横轴是”假正例率”(False Positive Rate，简称”FPR”)。 【真正例率(TPR)】:【真正例样本数】与【真实情况是正例的样本数】的比值（查全率） 【假正例率(FPR)】:【假正例样本数】与【真实情况是反例的样本数】的比值 公式如下：$$TPR = \frac{TP}{TP+FN}$$ $$FPR=\frac{FP}{TN+FP}$$ ROC图全名为“受试者工作特征”。 如图，(0,1)点为理想模型。随机模型则是真正例率与假正例率持平的直线，既对角线。 学习器进行比较时，与P-R图相似，若一个学习器的ROC曲线被另一个学习器曲线完全“包住”，则可断言后者的性能优于前者。 若ROC曲线发生交叉，则较为合理的判断是比较ROC曲线下的面积，即AUC(Area Under ROC Curve)。 代价敏感错误率与代价曲线因为在现实任务中会遇到这样的情况，不同类型的错误所造成的后果不同。拿上面西瓜的例子来说明，如果把好瓜当成坏瓜，等于浪费了一个好瓜；但是把坏瓜当成好瓜，就有可能让顾客吃坏肚子，不得不去就医。因此，为权衡不同类型错误所造成的不同损失，可为错误赋予”非均等代价(unequal cost)。” 说明一点：之前的介绍的性能度量，大多都隐性的假设了”均等假设”。 上图为二分类代价矩阵，其中$cost_{ij}$表示将第$i$类样本预测为第$j$类样本的代价。 值得说明一点：一般情况下，重要的是代价比值而非绝对值。例如：$cost_{01} : cost_{10} = 5:1$与$50:1$所起的效果相当。 在非均等代价下，希望做的不再是简单的最小化错误次数，而是希望最小化”总体代价(total cost)”。 例：若将表中第0类作为正例，第1类作为反类，则代价敏感(cost-sensitive)错误率为：$$E(f;D;cost)=\frac{1}{m}(\sum_{x_i \in D^+}\mathbb{I}(f(x_i) \neq y_i)\times cost_{01}+ \sum_{x_i \in D^-}\mathbb{I}(f(x_i)\neq y_i)\times cost_{10})$$在这样非均等代价下，ROC曲线不能直接反映出学习器的期望总体代价，而“代价曲线(cost curve)”则可以达到该目的。代价曲线图的横轴是取值[0,1]的正例率代价，纵轴是取值[0,1]的归一化代价。$$P(+)cost=\frac{p\times cost_{01}}{p\times cost_{01}+(1-p)\times cost_{10}}$$ $$cost_{norm} = \frac{FNR\times p\times cost_{01}+FPR\times (1-p)\times cost_{10}}{p\times cost_{01}+(1-p)\times cost_{10}}$$ 其中$p$是样例为正例的概率。 【假反利率(FNR)】：【假反例样本数】与【真实情况是正例的样本数】的比值。(1-查全率) 代价曲线的绘制方法： ROC曲线上取点(FPR,TPR)，则可计算出FNR 在代价平面上取两点(0,FPR)、(1,FNR)，并且连成线段，线段下面的面积即是该条件下的期望总体代价 去遍ROC曲线上所有的点，并重复第二步 所以线段下界就是学习期望总体代价]]></content>
      <categories>
        <category>机器学习</category>
        <category>精读西瓜书</category>
      </categories>
      <tags>
        <tag>模型评估与选择</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[精读西瓜书(二)]]></title>
    <url>%2F2018%2F09%2F03%2F%E7%B2%BE%E8%AF%BB%E8%A5%BF%E7%93%9C%E4%B9%A6-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[写在前面：第二章主要让我们了解经验误差与拟合，评估方法，比较检验以及偏差与方法，重点主要是评估方法，理解过拟合与欠拟合，roc曲线。 知识点归纳经验误差与过拟合【错误率(error rate)】：分类错误的样本占样本总数的比例 例：m个样本中有a个样本分类错误，则错误率$E = a / m$ 【精度(accuracy)】：分类正确的样本数占样本总数的比例 例：m个样本中有m-a个分类正确，则精度$A = 1 - E$ 【误差(error)】:学习器的实际预测输出与样本的真实输出之间的差异 例：比如有1000个西瓜，其中真实的好瓜有600个，但是学习器预测的只有400个，这之间的差异就是误差。 【训练误差(training error)或经验误差(empirical error)】：学习器在训练集上的误差 注意：学习器就是在训练集上训练出来的，但实际上在回到训练集上对样本进行结果预测的时候，仍会存在误差。（换句话说，就是结果值与标记值不同） 【泛化误差(generalization error)】:学习器在新样本上的误差 在机器学习中，我们希望做的以及实际能做的如下： 希望: 得到泛化误差最小的学习器，在新样本能表现的很好的学习器，尽可能学出适用于所有潜在样本的“普遍规律” 实际能做到的：努力使经验误差最小化，在训练集上表现的很好的学习器，但是有可能不是我们所希望得到的学习器 【过拟合(overfitting)】：学习能力过于强大。学习器把训练样本学得太好，导致将训练样本中自身的一些特点当做了所有潜在样本都会具有的一般性质，从而导致泛化能力下降。 例：比如10000个球形西瓜来当训练集，此时学习器得到的结果结果是球形西瓜是好瓜，但实际上有的方形西瓜也是好瓜，这就让学习器在面对方形西瓜时候泛化能力就变差了 【欠拟合(underfitting)】：学习能力低下，指对训练样本的一般性质尚未学好。 例：比如形状是判断是否好瓜的重要标准，但经过训练得到的决策树没有对形状进行判断的步骤。 我们实际能做的：努力使经验误差最小化，是指在“过拟合”与“欠拟合”之间寻找一种平衡，并且尽可能的使学习器在不太过拟合的情况下使得训练集的分类更准确，泛化能力更强。 **注意：任何学习算法都有针对过拟合的措施，但是过拟合是无法完全避免的，只能缓解或减小其风险，欠拟合是比较容易克服的。 【多项式时间(polynomial time)】：在计算复杂度理论中，指的是一个问题的计算时间m不大于问题大小n的多项式倍数。任何抽象机器都拥有一复杂度类，此类包括可用于此以多项式时间求解的问题。 关于p问题，NP问题和NPC问题的链接 关于多项式时间的链接 【P问题】：指的是能够在多项式的时间里得到解决的问题 【NP问题】：指的是能够在多项式的时间里验证一个解是否正确的问题 【证明过拟合无法避免】： 1.机器学习面临一个NP或更难的问题，即$\exists NP$ 2.有效的算法需要在多项式时间内运行完成，即$\exists P$ 3.当可彻底避免过拟合时，通过最小化经验误差就可获得最优解，即$P = NP$ 4.但是实际情况是$P \ne NP $，所以过拟合是无法避免的 评估方法模型选择(model selection)问题中，理想的解决方案当然是对候选模型的泛化误差进行评估，然后选择泛化误差最小的模型，但实际上，我们无法直接获得泛化误差，而训练误差又由于过拟合现在的存在而不适合作为标准，我们可以通过评估方法、性能度量等方法来进行模型选择。 希望：通过学习评估学习器的泛化误差，选出泛化误差最小的学习器 实际：泛化误差只能通过测试求得的测试误差来表现 为了通过实验测试来对学习器的泛化误差进行评估并进而做出选择，我们需要使用一个测试集(testing set)来测试学习器对新样本的判别能力，然后以测试误差(testing error)作为泛化误差的近似。 注意：测试集应尽可能与训练集互斥，即测试样本尽量不在训练集出现，未在训练过程中使用过。 【测试误差(testing error)】：学习器在测试集上的实际预测输出与测试样本的真实输出之间的差异 【数据集】：包含所有样例的数据集的集合。$D = {(x_1,y_1),(x_2,y_2),(x_3,y_3),\cdots,(x_m,y_m)}$ 注意：数据集既要训练，又要测试，所以通过对$D$进行适当的处理，从中产生训练集$S$和测试集$T$。 留出法【留出法(hold-out)】：直接将数据集$D$划分为两个互斥的集合，其中一个集合作为训练集$S$，另一个作为测试集$T$，即$D = S \cup T$，$S \cup T = \oslash $,在$S$上训练出模型后，用$T$ 来评估其测试误差，作为对泛化误差的估计。 需要注意的是，训练/测试集的划分要尽可能保持数据分布的一致性，避免因数据划分过程引入额外的偏差而对最终结果产生影响。通常使用分层采样。不同的划分会导致不同的训练/测试集，相应的模型评估的结果也会有差别。故单次使用留出法的估计结果往往不可靠，使用留出法一般要若干次随机划分，重复进行实验评估后取平均值作为留出法的评估结果。问题：我们评估的是用训练出的模型的性能，但留出法划分了数据集，使得实际上训练的数据集小了，若比例较大，训练的模型较为接近训练的模型，但是由于较小，评估结果可能就不太稳定准确。若令比重较大，则与差别就更大了。建议：训练集/测试集：2/3~4/5 例： 如上，可以看到是两个同心圆。其中红色的内圆是训练集，绿色的部分是测试集，两部分是互不包含的。 因为要保持数据分布的一致性，所以一般采用分层采样，所以如下图所示。（注：用圆心角来体现数据分布的一致性，无论是训练集还是测试集，均在360度范围内分布。） 单次使用留出法得到的估计结果往往不够稳定可靠，所以在使用留出法的时候，一般采用若干次随机划分，重复进行实验评估后取平均值作为留出法的评估结果。(例如进行100次划分，每次会产生一个评估结果，共得出100个评估结果，最后留出法返回的是这100个评估结果的平均值) 如上图，每次测试集取的是绿色的部分，所有得出的结果再取平均值，即时留出法的评估结果。 ###交叉验证法(重要) 【交叉验证法(cross validation)】：先将数据集$D$ 划分为$k$个大小相似的互斥子集，即$D = D_1 \cup D_2 \cup \dots \cup D_k$；$D_i \cap D_j = \emptyset( i \not= j)$ .但每个子集$D_i$ 都尽可能保持数据分布的一致性。 如上图所示，每个子集仍然要分层采样。每次用$k-1$子集作为训练集，余下的子集作为测试集。这样就可以获得$k$个测试结果，进行$k$次训练和测试，最终返回的是这$k$个测试结果的均值。 交叉验证法评估结果的稳定性和保真性在很大程度上取决于$k$的取值，所以通过把交叉验证法称为“k折交叉验证法(k-fold corss validation)”，k的常用值为10，下图为10折交叉验证法的图示。 与留出法相似，为了减小因样本划分不同而引入的差别，交叉验证法也需要进行多次试验，用不同的划分方法重复$p$次试验，最终的结果是是这$p$次$k$折交叉验证结果的均值。 总结： 交叉验证法得到的结果是均值的均值，即p个“k个结果的均值”的均值，因此交叉验证法又可以叫做p次k折交叉验证。 交叉验证法的特点： 1、每个子集都会做测试集 2、每个子集分层采样 3、单次k折，切换测试集试验取均值 4、k折划分p次，重复试验再取均值 优点：准确；缺点：开销大 自助法【自助法(bootstrapping)】：直接以自助采样法(bootstrapping sampling)为基础。给定包含$m$个样本的数据集$D$，我们对它进行采样数据集$D^\prime$：每次随机从$D$中挑选一个样本，将其拷贝放入$D^\prime$，再将该样本放回初始数据集$D$中，使得该样本在下次采样时仍有可能被采到，执行m次(有放回取$m$次)，我们可以得到包含m个样本的数据集$D^\prime$，这就是自助采样的结果。 按此类方法，保证了$D$和$D^\prime$的规模一致。但$D^\prime$虽然也有m个样本，可其中可能出现重复的样本，而$D$中会存在$D^\prime$采样没有采到的样本，这些样本就留作当测试集。 样本在$m$次采样中始终不被采到的概率是:$(1-\frac{1}{m})^m$，即取得的极限为：$$\lim_{m\to \infty}（1-\frac{1}{m}）^m \mapsto \frac{1}{e} \approx 0.368$$由上可知，初始数据集D中大约有36.8%的样本未出现在采样数据集$D^\prime$中，所以将$D^ \prime$用作训练集，$D$ \ $D^\prime$用作测试集。 优点：自助法在数据集较小，难以有效划分训练/测试集时很有效。能从初始数据集中产生多个不同的训练集，这样对集成学习等方法有很大的好处。 缺点：自助法产生的数据集改变了初始数据集的分布，会引入估计偏差。因此，在初始数据集量足够时，留出法和交叉验证法更常用一些。 调参与最终模型学习算法中都有参数(parameter)需要设定，参数配置的不同，学得模型的性能往往有显著差别。不仅要对适用学习算法进行选择，还需要对算法参数进行设定，这就是通常指的“参数调节”或简称“调参(parameter tuning)”。 参数调的好不好往往对最终模型性能有关键性影响。 注意以及说明： 通常把学得模型在实际使用中遇到的数据成为测试数据。 模型评估与选择中用于评估测试的数据集称为验证集(validation set)。以便加以区分。 例子： 在研究对比不同算法的泛化性能时，用测试集上的判别效果来估计模型在实际使用时的泛化能力，而把训练数据另外划分为训练集与验证集，基于验证集上的性能来进行模型选择和调参。]]></content>
      <categories>
        <category>机器学习</category>
        <category>精读西瓜书</category>
      </categories>
      <tags>
        <tag>模型评估与选择</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[精读西瓜书(一)]]></title>
    <url>%2F2018%2F09%2F02%2F%E7%B2%BE%E8%AF%BB%E8%A5%BF%E7%93%9C%E4%B9%A6-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[写在前面我们在这里将学习到以下： 机器学习定义 基本术语 假设空间 归纳偏好 发展历程(了解即可) ##何为机器学习 机器学习就是一门一门研究关于“学习算法”的学科。“学习算法”就是计算机从数据中产生的“模型”。“数据”可以类比于我们生活中的经验。我们可以基于经验来作出预判，机器学习也可以通过“学习算法”来作出预判。 基本术语数据集(data set)：数据的集合 样本(sample)或示例(instance):一个事件或对象 属性(attribute)或特征(feature):反映事件或对象在某方面的表现或性质 属性值(attribute value):属性上的值 属性空间(attribute space)或样本空间(sample space)或输入空间:属性张成的空间 特征向量(feature vector):样本空间中的所对应得点，维度是特征 训练集(training set):训练样本组成的集合为训练集，训练集可分为训练样本和验证样本，监督学习中有标记(label)y，非监督学习中没有标记y 测试集(testing set):学得模型后，用来预测的的数据集合 监督学习(supervised learning)：训练数据拥有标记信息，例如：回归(regression)，分类(classification)，SVM，决策树等 无监督学习(unsupervised learning):训练数据没有标记信息，例如：聚类(clustering) 泛化能力(generalization)：机器学习学习得到的模型能够很好适用于整个样本空间，并不单单适用于训练样本，这样适用于新样本的能力，成为泛化能力 假设空间归纳(induction):从特殊到一般的”泛化”过程，即从具体的事实归结出一般性规律 演绎(deduction):从一般到特殊的“特化”过程，即从基础原理推演出具体状况 机器学习是从样例中学习的，所以可以称为是”归纳学习”。 假设空间：是在学习过程中所有假设组成空间。 版本空间(version space)：一个与训练集一致的“假设集合” ####难点分析： 假设空间规模问题： 书中例子为西瓜，其中属性有三种，分别为色泽、根蒂、敲声 这三种属性分别有3/3/3种可能取值，但假设空间却是4x4x4+1 =65 这里的假设空间中，属性的“无论取什么属性值都合适，即通配符*”，也是一种属性值，而不是作为单一属性的三种可能取值的集合存在。 因此假设空间是： {青绿、乌黑、浅白、*} x {蜷缩、稍蜷、硬挺、*} x {浊响、清脆、沉闷、*} +1(没有“好瓜”的定义) = 65 归纳偏好对于一个具体的学习算法而言，需要要产生一个模型，这时候，学习算法本身的“偏好”就会起到关键的作用。 机器学习算法在学习过程中对某种类型假设的偏好，成为“归纳偏好(inductive bias)”,或简称为“偏好”。 任何一个有效的机器学习算法必有其归纳偏好。#####“奥卡姆剃刀原理(Occam’s razor)“: 若有多个假设与观察一致，则选择最简单的那个。注意：“奥卡姆剃刀“并非唯一可行的原则 #####“没有免费的午餐定理(No Free Lunch Theorem,简称NFL定理)“： 总误差与学习算法无关。 所以让我们理解并认识到： 脱离具体问题，空泛地谈论“什么学习算法更好”是毫无意义的。]]></content>
      <categories>
        <category>机器学习</category>
        <category>精读西瓜书</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matplotlib]]></title>
    <url>%2F2018%2F07%2F10%2FMatplotlib%2F</url>
    <content type="text"><![CDATA[数据展示及可视化 数据可视化的重要性 基本图表的绘制及应用场景 数据分析常用图标的绘制 Pandas及Seaborn绘图 其他常用的可视化工具 数据可视化准则 真实性(Truthful) 功能性(Functionality) 美观(Beauty) 深刻性(Insightful) 启发性(Enlightening) 12345#导入工具import matplotlibimport seaborn as snsimport numpy as np #和notebook交互的语言，目的是将图打印出来%matplotlib inline 12anscombe_df = sns.load_dataset('anscombe')anscombe_df.head(10) 查看样本方差 1anscombe_df.groupby('dataset').agg([np.mean, np.var]) #var是样本方差 sns可视化 12345sns.set(style="ticks")sns.lmplot(x="x", y="y", col="dataset", hue="dataset", data=anscombe_df, col_wrap=2, ci=None, palette="muted", size=4, scatter_kws=&#123;"s": 50, "alpha": 1&#125;) ##从这里的数据可以看出，可视化的重要性，数据是不一样的，虽然他们的mean和var都一样 ## 统计特性不一定能完全反应数据的特性 基本图表的绘制及应用场景Matplotlib 用于创建出版质量图表的绘图工具库 目的是为Python构建一个Matlab式的绘图接口 import matplotlib.pyplot as plt pyplot模块包含了常用的matplotlib API函数 Matplotlib构架 Backend层 用于处理向屏幕或文件渲染图形 在Jupyter，使用inline backend 什么是backend Artist层 包含图像绘制的容器，如Figure，Subplot及Axes 包含基本元素，如Line2D，Rectangle等 Scripting层 简化访问Artist和Backend层的过程 123# 用于在jupyter中进行绘图#%matplotlib notebook #非嵌入的图片 #嵌入图片见下面%matplotlib inline 1234# Backendimport matplotlib as mplmpl.get_backend() 结果： 1&apos;module://ipykernel.pylab.backend_inline&apos; 使用matplotlib.pyplot直接绘制12import matplotlib.pyplot as pltplt.plot(3, 2,'*') #需要指定mark 使用scripting 12345678910#使用scripting层绘制from matplotlib.backends.backend_agg import FigureCanvasAggfrom matplotlib.figure import Figurefig = Figure()canvas = FigureCanvasAgg(fig)ax = fig.add_subplot(111)ax.plot(3, 2, '.')canvas.print_png('test.png') ##保存图片 pyplot pyplot 可通过gcf(get current figure)获取当前图像对象，gca(get current axis)获取当前坐标轴对象 可以通过pyplot.plot()进行绘图，其底层调用的还是axes.plot()函数 多参考相关的API文档 123456#gca获取当前坐标对象plt.figure()plt.plot(3, 2, 'o')ax = plt.gca() #获取当前坐标轴# 设置坐标轴范围ax.axis([0, 6, 0, 10]) matplotlib会自动用颜色区分不同数据 12345# matplot 会自动用颜色区分不同的数据plt.figure()plt.plot(1.5, 1.5, 'o')plt.plot(2, 2, '*')plt.plot(2.5, 2.5, '*') 散点图 plt.scatter() scatter_API zip封装及解包 坐标标签plt.xlabel(),plt.ylabel()，标题plt.title()，图例plt.legend() 颜色、标记、线性 axplot(x,y,’r–’) 等价于ax.plot(x,y,linestyle = ‘–’,color = ‘r’) 123456import numpy as npx = np.array([1, 2, 3, 4, 5, 6, 7, 8])y = xplt.figure()plt.scatter(x, y) 改变颜色及大小 12345678910# 改变颜色及大小import numpy as npx = np.array([1, 2, 3, 4, 5, 6, 7, 8])y = xcolors = ['red'] * (len(x) - 1)colors.append('green')plt.figure()plt.scatter(x, y, s=100, c=colors) 用zip合并为一个新的列表 12345678# 使用zip合并两个列表为一个新列表# 新列表中的每个元素为对应位置上的元组l1 = list(range(1, 6))l2 = list(range(6, 11))zip_generator = zip(l1, l2) #生成器tuple_list = list(zip_generator)print(type(zip_generator))print(list(tuple_list)) 结果： 12&lt;class 'zip'&gt;[(1, 6), (2, 7), (3, 8), (4, 9), (5, 10)] 使用*进行对元组列表解包 1234# 使用*进行对元组列表解包x, y = zip(*tuple_list)print(x)print(y) 结果： 12(1, 2, 3, 4, 5)(6, 7, 8, 9, 10) 设置中文字符 123456789101112131415plt.figure()plt.scatter(x[:2], y[:2], c='red', label='samples 1')plt.scatter(x[2:], y[2:], c='blue', label='samples2')# 添加坐标标签，标题，如果用中文需要加下面的中文设置代码plt.xlabel('数值1')plt.ylabel('数值2')plt.title('散点图')# 添加图例# plt.legend()# 4: 右下角 plt.legend(loc=4, frameon=True, title='Legend') #frameon指是否加边框，best是最佳位置plt.rcParams["font.sans-serif"] = ["SimHei"] #设置中文字符，如果不加这行，只能用英文 线图 plt.plot() 填充线间的区域 plt.gca().fill_between() np.array()生成时间数据 np.array(‘2017-01-01,’2017-01-08’,dtype = ‘datetime64[D]’) 绘制图像的坐标轴为时间数据时，可以借助pandas的to_datetime()完成 旋转坐标轴文字的方向 plt.xticks(rotation = )或遍历ticks进行set_rotation() 调整边界距离，plt.subplots_adjust() plot 12345678910111213141516171819202122232425import numpy as nplinear_data = np.arange(1, 9)quadratic_data = linear_data ** 2plt.figure()plt.plot(linear_data, '-o', quadratic_data, '-o')# 注意，这里我们只指定了y轴数据，x轴的数据是matplotlib自动生成的plt.plot([22, 44, 66], '--r')# 添加坐标轴标签及图例plt.xlabel('x data')plt.ylabel('y data')plt.title('Line Chart Title')plt.legend(['legend1', 'legend2', 'legend3'])# 填充两个line间的区域plt.gca().fill_between(range(len(linear_data)), linear_data, quadratic_data, facecolor='green', alpha=0.25)plt.savefig("examples.jpg") #保存图片## 绘制横轴为时间的线图 1234567# 绘制横轴为时间的线图plt.figure()observation_dates = np.arange('2017-10-11', '2017-10-19', dtype='datetime64[D]')observation_datesplt.plot(observation_dates, linear_data, '-o', observation_dates, quadratic_data, '-o')# 横轴并不是我们想要的结果 借用pandas绘制横轴为时间的线图 12345678910111213141516171819# 借助pandas绘制横轴为时间的线图import pandas as pdplt.figure()observation_dates = np.arange('2017-10-11', '2017-10-19', dtype='datetime64[D]')observation_dates = list(map(pd.to_datetime, observation_dates))plt.plot(observation_dates, linear_data, '-o', observation_dates, quadratic_data, '-o')# plt.xticks(rotation='45') #用这个比较好，转角45度x = plt.gca().xaxis for item in x.get_ticklabels(): item.set_rotation(45) # 调整边界距离plt.subplots_adjust(bottom=0.25)# 对于学术制图，可在标题中包含latex语法ax = plt.gca()ax.set_title('Quadratic ($x^2$) vs. Linear ($x$)') 柱状图 plt.bar() group bar chart 同一副图中包含多个柱状图时，注意要对x轴的数据做相应的移动，避免柱状图重叠 stack bar chart 使用bottom参数 横向柱状图 barh 相应的参数width变为参数height；bottom变为left 123456789plt.figure()x_vals = list(range(len(linear_data)))plt.bar(x_vals, linear_data, width=0.3)# group bar chart# 同一副图中添加新的柱状图# 注意，为了不覆盖第一个柱状图，需要对x轴做偏移，必须通过偏移来完成x_vals2 = [item + 0.3 for item in x_vals]plt.bar(x_vals2, quadratic_data, width=0.3) 重叠柱状图 12345# stack bar chartplt.figure()x_vals = list(range(len(linear_data)))plt.bar(x_vals, linear_data, width=0.3)plt.bar(x_vals, quadratic_data, width=0.3, bottom=linear_data) 横向柱状图 12345# 横向柱状图plt.figure()x_vals = list(range(len(linear_data)))plt.barh(x_vals, linear_data, height=0.3)plt.barh(x_vals, quadratic_data, height=0.3, left=linear_data) 应用场景 散点图，适用于二维或三维数据集，但其中只有两维需要比较 线图，适用于二维数据集，适合进行趋势的比较 柱状图，适用于二维数据集，但只有一个维度需要比较，利用柱子的高度反映数据的差异 数据分析常用图标的绘制Subplots plt.subplots() 建立子图 subplot_api 12345678910111213141516171819%matplotlib inlineimport matplotlib.pyplot as pltimport numpy as npplt.figure()# 表示1行2列，现在在第一个子图上进行操作plt.subplot(1, 2, 1)linear_data = np.arange(1, 9)plt.plot(linear_data, '-o')#在第二个子图上画图exponential_data = linear_data ** 2plt.subplot(1, 2, 2)plt.plot(exponential_data, '-x')plt.subplot(1, 2, 1)plt.plot(exponential_data, '-x') 保证子图坐标范围一致 123456# 保证子图中坐标范围一致plt.figure()ax1 = plt.subplot(1, 2, 1)plt.plot(linear_data, '-o')ax2 = plt.subplot(1, 2, 2, sharey=ax1) plt.plot(exponential_data, '-x') 建子图 1234#建子图fig, ((ax1, ax2, ax3), (ax4, ax5, ax6)) = plt.subplots(2, 3, sharex=True, sharey=True)ax5.plot(exponential_data, '-') 直方图 对数据分布情况的图表示 首先要对数据进行分组，然后统计每个分组内数据的数量 作用： 显示各分组频率或数量分布的情况 易于显示各组之间频率或数量的差别 plt.hist(data,bins) data:数据列表 bins:分组边界或分组个数 直方图_api 1234567891011fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, sharex=True)axs = [ax1, ax2, ax3, ax4]plt.rcParams['axes.unicode_minus']=False #用来正常显示负号for n in range(len(axs)): sample_size = 10 ** (n + 1) sample = np.random.normal(loc=0., scale=1., size=sample_size) # 默认bin的个数为10 axs[n].hist(sample) axs[n].set_title('n=&#123;&#125;'.format(sample_size)) 12345678910fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, sharex=True)axs = [ax1, ax2, ax3, ax4]for n in range(len(axs)): sample_size = 10 ** (n + 1) sample = np.random.normal(loc=0., scale=1., size=sample_size) # bin设为100 #axs[n].hist(sample, bins=100) axs[n].hist(sample,normed = True) #normed是归一化 axs[n].set_title('n=&#123;&#125;'.format(sample_size)) 使用gridspec和直方图绘制一个复杂的分析图 1234567891011121314151617# 使用gridspec和直方图绘制一个复杂分析图import matplotlib.gridspec as gridspecx = np.random.random(size=10000)y = np.random.normal(loc=0., scale=1., size=10000)plt.figure()gspec = gridspec.GridSpec(3, 3)top_hist = plt.subplot(gspec[0, 1:])side_hist = plt.subplot(gspec[1:, 0])lower_right = plt.subplot(gspec[1:, 1:])lower_right.scatter(x, y,alpha = 0.3 ) #alpha是透明度top_hist.hist(x, bins=100, normed=True)side_hist.hist(y, bins=100, orientation='horizontal', normed=True)side_hist.invert_xaxis() 盒形图 详细说明 plt.boxplot() whis默认为1.5启用离群值；’range’为不启用离群值 盒形图_api 1234567891011import pandas as pd# 正态分布采样normal_sample = np.random.normal(loc=0., scale=1., size=10000)# 随机数采样random_sample = np.random.random(size=10000)# gamma分布采样gamma_sample = np.random.gamma(2, size=10000)df = pd.DataFrame(&#123;'normal': normal_sample, 'random': random_sample, 'gamma': gamma_sample&#125;) 1df.describe() 盒形图 12plt.figure()plt.boxplot(df['normal'], whis='range') 12plt.figure()plt.boxplot([df['normal'], df['random'], df['gamma']], whis='range') 12plt.figure()plt.boxplot([df['normal'], df['random'], df['gamma']]) 热图 热图_api 可用于三维数据的可视化 plt.imshow(arr) plt.hist2d() plt.colorbar()添加颜色条 1234plt.figure()y = np.random.normal(loc=0., scale=1., size=10000)x = np.random.random(size=10000)plt.hist2d(x, y, bins=25) 结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091(array([[ 0., 0., 0., 0., 0., 4., 8., 12., 29., 26., 41., 51., 52., 40., 37., 49., 22., 15., 8., 4., 1., 1., 0., 1., 0.], [ 0., 1., 0., 0., 5., 3., 7., 18., 27., 32., 38., 54., 44., 45., 38., 23., 30., 11., 4., 4., 0., 1., 0., 0., 0.], [ 0., 0., 1., 3., 1., 7., 10., 18., 29., 24., 35., 43., 50., 50., 36., 28., 25., 16., 3., 5., 1., 1., 0., 1., 0.], [ 0., 0., 1., 1., 5., 4., 12., 15., 19., 35., 39., 32., 55., 51., 44., 24., 23., 13., 8., 5., 0., 1., 0., 0., 0.], [ 0., 1., 0., 2., 1., 6., 6., 14., 28., 33., 46., 43., 44., 40., 45., 26., 17., 20., 6., 5., 5., 0., 1., 0., 0.], [ 0., 0., 1., 0., 3., 8., 9., 17., 25., 45., 31., 46., 63., 44., 33., 19., 24., 8., 9., 5., 1., 0., 1., 0., 0.], [ 0., 0., 0., 1., 1., 9., 10., 21., 27., 27., 47., 34., 41., 53., 46., 24., 16., 14., 12., 8., 3., 0., 0., 0., 0.], [ 0., 0., 0., 1., 2., 1., 12., 11., 28., 25., 44., 51., 54., 46., 42., 37., 16., 16., 3., 5., 3., 1., 0., 0., 0.], [ 0., 0., 0., 1., 1., 5., 17., 11., 23., 20., 36., 48., 49., 37., 44., 24., 20., 11., 5., 4., 2., 0., 1., 0., 0.], [ 1., 0., 0., 1., 0., 8., 10., 19., 25., 44., 39., 45., 45., 40., 30., 24., 18., 11., 4., 6., 5., 0., 0., 1., 0.], [ 0., 0., 1., 0., 3., 3., 14., 10., 19., 45., 36., 57., 50., 53., 42., 26., 21., 12., 4., 10., 3., 1., 0., 0., 0.], [ 1., 0., 0., 2., 2., 7., 7., 15., 20., 36., 45., 53., 38., 55., 32., 25., 21., 13., 9., 1., 0., 0., 0., 0., 0.], [ 0., 0., 1., 3., 1., 7., 10., 14., 27., 40., 46., 47., 50., 51., 44., 30., 20., 16., 9., 2., 1., 1., 0., 0., 0.], [ 0., 0., 1., 0., 2., 10., 11., 24., 28., 42., 36., 51., 41., 46., 31., 26., 22., 12., 11., 2., 3., 1., 1., 0., 0.], [ 0., 0., 1., 2., 4., 6., 16., 15., 31., 32., 44., 53., 52., 52., 49., 34., 23., 16., 11., 9., 2., 0., 0., 0., 0.], [ 0., 0., 1., 2., 2., 5., 12., 10., 27., 31., 36., 37., 55., 42., 42., 33., 36., 12., 7., 4., 1., 0., 0., 0., 0.], [ 0., 0., 1., 2., 0., 11., 13., 12., 26., 28., 43., 32., 61., 52., 35., 40., 26., 11., 8., 2., 0., 0., 1., 0., 0.], [ 0., 0., 0., 2., 0., 8., 7., 17., 14., 32., 45., 44., 56., 46., 39., 27., 19., 16., 10., 6., 2., 1., 0., 0., 0.], [ 1., 0., 1., 1., 4., 4., 5., 20., 27., 41., 44., 44., 48., 53., 38., 37., 20., 13., 6., 2., 3., 0., 0., 0., 0.], [ 0., 0., 0., 2., 2., 3., 8., 26., 26., 35., 43., 49., 40., 54., 40., 27., 28., 13., 9., 2., 1., 1., 0., 0., 1.], [ 0., 0., 0., 2., 0., 5., 8., 10., 19., 33., 35., 53., 52., 50., 47., 22., 22., 22., 10., 4., 4., 0., 1., 0., 1.], [ 1., 0., 1., 0., 3., 4., 4., 9., 23., 38., 37., 59., 56., 45., 35., 37., 23., 13., 6., 1., 3., 1., 0., 1., 0.], [ 0., 0., 0., 1., 2., 5., 5., 22., 21., 30., 43., 54., 57., 47., 35., 42., 28., 13., 11., 3., 1., 0., 0., 0., 0.], [ 1., 0., 0., 0., 3., 3., 7., 8., 21., 36., 36., 63., 60., 47., 53., 35., 28., 14., 8., 4., 1., 0., 2., 0., 0.], [ 0., 0., 0., 0., 5., 7., 10., 26., 22., 27., 39., 40., 53., 49., 40., 33., 22., 9., 13., 5., 3., 2., 0., 0., 0.]]), array([ 8.27648177e-05, 4.00777802e-02, 8.00727956e-02, 1.20067811e-01, 1.60062826e-01, 2.00057842e-01, 2.40052857e-01, 2.80047873e-01, 3.20042888e-01, 3.60037903e-01, 4.00032919e-01, 4.40027934e-01, 4.80022950e-01, 5.20017965e-01, 5.60012980e-01, 6.00007996e-01, 6.40003011e-01, 6.79998026e-01, 7.19993042e-01, 7.59988057e-01, 7.99983073e-01, 8.39978088e-01, 8.79973103e-01, 9.19968119e-01, 9.59963134e-01, 9.99958150e-01]), array([-3.87298648, -3.56051544, -3.2480444 , -2.93557336, -2.62310232, -2.31063128, -1.99816024, -1.6856892 , -1.37321816, -1.06074712, -0.74827608, -0.43580504, -0.123334 , 0.18913704, 0.50160808, 0.81407912, 1.12655016, 1.4390212 , 1.75149224, 2.06396328, 2.37643431, 2.68890535, 3.00137639, 3.31384743, 3.62631847, 3.93878951]), &lt;matplotlib.image.AxesImage at 0x20b1d6959b0&gt;) 热度 123456plt.figure()y = np.random.normal(loc=0., scale=1., size=10000)x = np.random.random(size=10000)plt.hist2d(x, y, bins=100)plt.colorbar() Pandas及Seaborn绘图Pandas df.plot(kind = ) kind用于指定绘图的类型 pd.plotting.scatter_matrix() pd.plotting.parrallel_coordinates() dataframe绘图 12345import pandas as pdimport numpy as npimport matplotlib.pyplot as plt%matplotlib inline 12# panda绘图，可用的绘图样式 plt.style.available 结果： 1234567891011121314151617181920212223242526[&apos;bmh&apos;, &apos;classic&apos;, &apos;dark_background&apos;, &apos;fast&apos;, &apos;fivethirtyeight&apos;, &apos;ggplot&apos;, &apos;grayscale&apos;, &apos;seaborn-bright&apos;, &apos;seaborn-colorblind&apos;, &apos;seaborn-dark-palette&apos;, &apos;seaborn-dark&apos;, &apos;seaborn-darkgrid&apos;, &apos;seaborn-deep&apos;, &apos;seaborn-muted&apos;, &apos;seaborn-notebook&apos;, &apos;seaborn-paper&apos;, &apos;seaborn-pastel&apos;, &apos;seaborn-poster&apos;, &apos;seaborn-talk&apos;, &apos;seaborn-ticks&apos;, &apos;seaborn-white&apos;, &apos;seaborn-whitegrid&apos;, &apos;seaborn&apos;, &apos;Solarize_Light2&apos;, &apos;tableau-colorblind10&apos;, &apos;_classic_test&apos;] 设置绘图样式 12# 设置绘图样式plt.style.use('seaborn-colorblind') 1234567#dataframe绘图np.random.seed(100)df = pd.DataFrame(&#123;'A': np.random.randn(365).cumsum(0), 'B': np.random.randn(365).cumsum(0) + 20, 'C': np.random.randn(365).cumsum(0) - 20&#125;, index=pd.date_range('2017/1/1', periods=365))df.head() 散点图绘图 1df.plot('A', 'B', kind='scatter') 123456# 颜色(c)和大小(s)有'B'列的数据决定ax = df.plot('A', 'C', kind='scatter', c='B', s=df['B'], colormap='viridis')# 设置坐标为相同比例ax.set_aspect('equal') 盒形图 1df.plot(kind='box') 直方图 1df.plot(kind='hist', alpha=0.7) 拟合分布图 1df.plot(kind='kde') #拟合分布图 查看变量间的关系 123#pandas.tools.plottingiris = pd.read_csv('iris.csv')iris.head() 12# 用于查看变量间的关系pd.plotting.scatter_matrix(iris) #每俩俩之间的关系 查看多变量分布 123# 用于查看多遍量分布plt.figure()pd.plotting.parallel_coordinates(iris, 'Name') #平行坐标 Seaborn 一个制图工具库，可以制作出吸引人的，信息量大的统计图 在Matplotlib上构建，支持numpy和pandas的数据结构可视化，甚至是scipy和statsmodels的统计模型可视化 特点： 多个内置主题和颜色主题 可视化单一变量、二维变量用于比较数据集中各变量的分布情况 可视化线性回归模型中的独立变量及不独立变量 可视化矩阵数据，通过聚类算法探究矩阵间的结构 可视化时间序列数据及不确定性的展示 可在分各区域制图，用于复杂的可视化 安装： conda install seaborn pip install seaborn 数据集分布可视化 单变量分布 sns.ditplot() 直方图 sns.distplot(kde = False) 核密度估计 sns.distplot(hist = False)或sns.kdeplot() 拟合参数分布 sns.distplot(kde = False,fit = ) 双变量分布 散布图 sns.joinplot() 二维直方图 Hexbin.sns.jointplot(kind = ‘hex’) 核密度估计 sns.jointplot(kind = ‘kde’) 类别数据可视化 类别散布图 sns.stripplot() 数据点会重叠 sns.swarmplot() 数据点避免重叠 hue指定子类别 类别内数据分布 盒子图 sns.boxplot,hue指定子类别 小提琴图 sns.violinplot(), hue指定子类别 类别内统计图 柱状图 sns.barplot() 点图 sns.pointplot() 类别内统计图 12#导入seaborn工具import seaborn as sns 123np.random.seed(100)v1 = pd.Series(np.random.normal(0, 10, 1000), name='v1')v2 = pd.Series(2 * v1 + np.random.normal(60, 15, 1000), name='v2') 12345# 通过matplotlib绘图plt.figure()plt.hist(v1, alpha=0.7, bins=np.arange(-50, 150, 5), label='v1')plt.hist(v2, alpha=0.7, bins=np.arange(-50, 150, 5), label='v2')plt.legend() 绘制直方图和折线拟合 1234plt.figure()plt.hist([v1, v2], histtype='barstacked', normed=True)v3 = np.concatenate((v1, v2))sns.kdeplot(v3) 使用seaborn绘图 123# 使用seaborn绘图plt.figure()sns.distplot(v3) 123# 使用seaborn绘图plt.figure()sns.jointplot(v1, v2, alpha=0.4) 1234# 使用seaborn绘图plt.figure()grid = sns.jointplot(v1, v2, alpha=0.4)grid.ax_joint.set_aspect('equal') 12plt.figure()sns.jointplot(v1, v2, kind='hex') 密度曲线 12plt.figure()sns.jointplot(v1, v2, kind='kde') #kde是密度曲线 密度曲线图 12iris = pd.read_csv('iris.csv')iris.head() 1sns.pairplot(iris, hue='Name', diag_kind='kde') 12345plt.figure()plt.subplot(121)sns.swarmplot('Name', 'PetalLength', data=iris)plt.subplot(122)sns.violinplot('Name', 'PetalLength', data=iris) 其他常用的可视化工具（可交互）D3.js D3(Data- Driven Documents),是一个用动态图形显示数据的JavaScript库，一个可视化工具 mpld3 参考链接 pip install mpld3 12345import pandas as pdimport numpy as npimport matplotlib.pyplot as plt%matplotlib inline 123##交互式图例import mpld3from mpld3 import plugins 123456np.random.seed(100)df = pd.DataFrame(&#123;'A': np.random.randn(365).cumsum(0), 'B': np.random.randn(365).cumsum(0) + 20, 'C': np.random.randn(365).cumsum(0) - 20&#125;, index=range(365))df.head() 查看列的名字 1df.columns.values 结果： 1array([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;], dtype=object) 绘制的是一个交互式图 1234567fig, ax = plt.subplots(figsize=(12, 8))labels = df.columns.tolist()lines = ax.plot(df.index.values, df.values, lw=2)interactive_legend = plugins.InteractiveLegendPlugin(lines, labels)plugins.connect(fig, interactive_legend)mpld3.display() 123#图像保存成htmlwith open('./interactive_legend_eg.html', 'w') as f: mpld3.save_html(fig, f) echarts 一个纯Javascript的图标库，可以流畅的运行在PC和移动设备上，兼容当前绝大部分浏览器，底层依赖轻量级的Canvas类库ZRender，提供直观，生动，可交互，可高度个性化定制的数据可视化图标。 pyecharts 参考链接 pip install pyecharts 详细用法 与Python进行对接，方便在Python中直接使用数据生成图 12345#柱状图交互式图例from pyecharts import Barcomp_df = pd.read_csv('./comparison_result.csv', index_col='state')comp_df 堆叠柱状图也是一个交互式图 123456789101112131415good_state_results = comp_df.iloc[0, :].valuesheavy_state_results = comp_df.iloc[1, :].valueslight_state_results = comp_df.iloc[2, :].valuesmedium_state_results = comp_df.iloc[3, :].valueslabels = comp_df.index.values.tolist()city_names = comp_df.columns.tolist()bar = Bar("堆叠柱状图")bar.add('良好', city_names, good_state_results, is_stack=True, xaxis_interval=0, xaxis_rotate=30)bar.add('轻度污染', city_names, light_state_results, is_stack=True, xaxis_interval=0, xaxis_rotate=30)bar.add('中度污染', city_names, medium_state_results, is_stack=True, xaxis_interval=0, xaxis_rotate=30)bar.add('重度污染', city_names, heavy_state_results, is_stack=True, xaxis_interval=0, xaxis_rotate=30)bar 12# 保存结果到htmlbar.render('./echarts_demo.html') 相关链接：源文件]]></content>
      <categories>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pandas]]></title>
    <url>%2F2018%2F07%2F09%2FPandas%2F</url>
    <content type="text"><![CDATA[Pandas进阶及统计分析基本数据对象及操作数据清洗数据合并及分组透视表 基本数据对象及操作 2008年由Wes McKinney创建 一个强大的分析结构化数据的工具集 基础是NumPy，提供了高性能矩阵的运算 链接：pandas Series 类似一维数组的对象 通过list构建Series ser_obj = pd.Series(range(10)) 123456import pandas as pdcountries = ['中国', '美国', '澳大利亚']countries_s = pd.Series(countries)print(type(countries_s)) #series的数据类型print(countries_s) 结果： 12345&lt;class 'pandas.core.series.Series'&gt;0 中国1 美国2 澳大利亚dtype: object index对象 1countries_s.index #index对象 结果： 1RangeIndex(start=0, stop=3, step=1) 看series和array的关系 1countries_s.values #可以看出series和array的关系 结果： 1array(['中国', '美国', '澳大利亚'], dtype=object) 由数据和索引组成 索引在左，数据在右 索引是自动创建的 12numbers = [4, 5, 6]print(pd.Series(numbers)) #见下面结果 索引（index）0、1、2 是自动创建的 结果： 12340 41 52 6dtype: int64 获取数据和索引 ser_obj.index , ser_obj.values 预览数据 ser_obj.head(n) 123456789101112131415161718country_dicts = &#123;'CH': '中国', 'US': '美国', 'AU': '澳大利亚'&#125; country_dict_s = pd.Series(country_dicts) #根据字典来创建series# 给索引命名country_dict_s.index.name = 'Code' # 给数据命名country_dict_s.name = 'Country'print(country_dict_s)print('-----------------------')print(country_dict_s.values) #获取数据print(country_dict_s.index) #获取索引print('-----------------------')print(country_dict_s)print('-----------------------')print(country_dict_s.head(2)) #预览前两行 结果： 12345678910111213141516171819CodeAU 澳大利亚CH 中国US 美国Name: Country, dtype: object-----------------------['澳大利亚' '中国' '美国']Index(['AU', 'CH', 'US'], dtype='object', name='Code')-----------------------CodeAU 澳大利亚CH 中国US 美国Name: Country, dtype: object-----------------------CodeAU 澳大利亚CH 中国Name: Country, dtype: object 处理缺失数据 如object—-&gt; None, float—–&gt;NaN 12345countries = ['中国', '美国', '澳大利亚', None]print(pd.Series(countries))print('-----------------------')numbers = [4, 5, 6, None]print(pd.Series(numbers)) 结果： 12345678910110 中国1 美国2 澳大利亚3 Nonedtype: object-----------------------0 4.01 5.02 6.03 NaNdtype: float64 Series索引数据 123456789country_dicts = &#123;'CH': '中国', 'US': '美国', 'AU': '澳大利亚'&#125;country_dict_s = pd.Series(country_dicts)country_dict_s.name = 'Country' country_dict_s.index.name = 'Code'print(country_dict_s) 结果： 12345CodeAU 澳大利亚CH 中国US 美国Name: Country, dtype: object 通过索引判断数据是存在 1234# 通过索引判断数据是存在# Series也可看作定长、有序的字典print('CH' in country_dict_s) print('NZ' in country_dict_s) 结果： 12TrueFalse 几种获取数据的方法 12345678910#几种获取数据的方法print('iloc:', country_dict_s.iloc[1]) #通过索引位置（整型数据）获取数据，ser_obj.iloc[idx]print('loc:', country_dict_s.loc['US']) #通过索引名（字符串）获取数据，ser_obj['idx_name'],ser_obj.loc['idx_name']print('[]:', country_dict_s['US'])print('-----------------------------------')#对series进行索引切片print('iloc:\n', country_dict_s.iloc[ [0, 2] ])print('--------------------------------------')print('loc:\n', country_dict_s.loc[['US', 'AU']]) 结果： 123456789101112131415iloc: 中国loc: 美国[]: 美国-----------------------------------iloc: CodeAU 澳大利亚US 美国Name: Country, dtype: object--------------------------------------loc: CodeUS 美国AU 澳大利亚Name: Country, dtype: object 向量化操作 123456#通过时间的对比来观察向量化操作的优势import numpy as nps = pd.Series(np.random.randint(0, 1000, 10000))print(s.head())print(len(s)) 结果： 12345670 6101 7182 3313 4964 429dtype: int3210000 通过时间的对比，来突出向量化操作可以缩短时间 1234%%timeit -n 100 # %%只能在jyputer上使用 #对所有数据进行求和total = 0for item in s: total += item 结果： 1656 µs ± 63.9 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) 对比上面循环操作，下方的整体操作可以大幅度缩小运行时间 12%%timeit -n 100total = np.sum(s) 结果： 1149 µs ± 40.3 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) DataFrame链接：dataframe 类似多维数组/表格数据（如，excel，R中的data.frame） 每列数据可以是不同的类型 索引包括行索引(index)和列索引(label) 创建Dataframe 123456789101112131415161718import pandas as pdcountry1 = pd.Series(&#123;'Name': '中国', 'Language': 'Chinese', 'Area': '9.597M km2', 'Happiness Rank': 79&#125;)country2 = pd.Series(&#123;'Name': '美国', 'Language': 'English (US)', 'Area': '9.834M km2', 'Happiness Rank': 14&#125;)country3 = pd.Series(&#123;'Name': '澳大利亚', 'Language': 'English (AU)', 'Area': '7.692M km2', 'Happiness Rank': 9&#125;)df = pd.DataFrame([country1, country2, country3], index=['CH', 'US', 'AU']) #通过dict构dataframe 注意在jupyter中使用print和不使用print的区别 123# 注意在jupyter中使用print和不使用print的区别print(df)df 下面为print打印的结果 1234 Area Happiness Rank Language NameCH 9.597M km2 79 Chinese 中国US 9.834M km2 14 English (US) 美国AU 7.692M km2 9 English (AU) 澳大利亚 下面为直接df后出来的图表 &lt;% qnimg p1.png %&gt; 添加值（values） 123456789# 添加数据# 如果个数小于要求的个数，会自动进行“广播”操作# 如果大于要求的个数，会报错df['Location'] = '地球'print(df)df['Region'] = ['亚洲', '北美洲', '大洋洲']# print(df)df 结果： 1234 Area Happiness Rank Language Name LocationCH 9.597M km2 79 Chinese 中国 地球US 9.834M km2 14 English (US) 美国 地球AU 7.692M km2 9 English (AU) 澳大利亚 地球 Dataframe索引注意：从DataFrame中取出的数据进行操作后，会对原始数据产生影响。为了保证不对原始数据产生影响，应该使用copy()产生一个副本。在副本上进行操作。 1234567# 行索引print('loc:')print(df.loc['CH'])print(type(df.loc['CH']))print('------------------------')print('iloc:')print(df.iloc[1]) 结果： 123456789101112131415161718loc:Area 9.597M km2Happiness Rank 79Language ChineseName 中国Location 地球Region 亚洲Name: CH, dtype: object&lt;class 'pandas.core.series.Series'&gt;------------------------iloc:Area 9.834M km2Happiness Rank 14Language English (US)Name 美国Location 地球Region 北美洲Name: US, dtype: object 列索引 123# 列索引print(df['Area'])print(type(df['Area'])) 结果： 12345CH 9.597M km2US 9.834M km2AU 7.692M km2Name: Area, dtype: object&lt;class 'pandas.core.series.Series'&gt; 获取不连续的列数据 12# 获取不连续的列数据print(df[['Name', 'Area']]) 结果： 1234 Name AreaCH 中国 9.597M km2US 美国 9.834M km2AU 澳大利亚 7.692M km2 混合索引 12345678910# 混合索引# 注意写法上的区别 #连锁性的数据访问print('先取出列，再取行：')print(df['Area']['CH'])print(df['Area'].loc['CH'])print(df['Area'].iloc[0])print('---------------------------------')print('先取出行，再取列：') #因为什么也不加，dataframe是默认先取列，所以df['CH']会报错，所以需要加loc或ilocprint(df.loc['CH']['Area'])print(df.iloc[0]['Area']) 结果： 12345678先取出列，再取行：9.597M km29.597M km29.597M km2---------------------------------先取出行，再取列：9.597M km29.597M km2 转换行和列 12# 转换行和列print(df.T) 结果： 1234567 CH US AUArea 9.597M km2 9.834M km2 7.692M km2Happiness Rank 79 14 9Language Chinese English (US) English (AU)Name 中国 美国 澳大利亚Location 地球 地球 地球Region 亚洲 北美洲 大洋洲 删除数据 12345678print(df.drop(['CH']))print('===================================')# 注意drop操作只是将修改后的数据copy一份，而不会对原始数据进行修改print(df)print('===================================')#修改df_1 = df.drop(['CH'])print(df_1) 结果： 123456789101112 Area Happiness Rank Language Name Location RegionUS 9.834M km2 14 English (US) 美国 地球 北美洲AU 7.692M km2 9 English (AU) 澳大利亚 地球 大洋洲=================================== Area Happiness Rank Language Name Location RegionCH 9.597M km2 79 Chinese 中国 地球 亚洲US 9.834M km2 14 English (US) 美国 地球 北美洲AU 7.692M km2 9 English (AU) 澳大利亚 地球 大洋洲=================================== Area Happiness Rank Language Name Location RegionUS 9.834M km2 14 English (US) 美国 地球 北美洲AU 7.692M km2 9 English (AU) 澳大利亚 地球 大洋洲 inplace的参数 123print(df.drop(['CH'], inplace=True))# 如果使用了inplace=True，会在原始数据上进行修改，同时不会返回一个copy，慎用print(df) 结果： 123 Area Happiness Rank Language Name Location RegionUS 9.834M km2 14 English (US) 美国 地球 北美洲AU 7.692M km2 9 English (AU) 澳大利亚 地球 大洋洲 删除列时，对axis的指定，0和1要区别（1是对列操作，0是对行操作） 123# 如果需要删除列，需要指定axis=1print(df.drop(['Area'], axis=1))print(df) 结果： 123456 Happiness Rank Language Name Location RegionUS 14 English (US) 美国 地球 北美洲AU 9 English (AU) 澳大利亚 地球 大洋洲 Area Happiness Rank Language Name Location RegionUS 9.834M km2 14 English (US) 美国 地球 北美洲AU 7.692M km2 9 English (AU) 澳大利亚 地球 大洋洲 也可以直接使用del关键字进行删除 123# 也可直接使用del关键字del df['Name']print(df) 结果： 123 Area Happiness Rank Language Location RegionUS 9.834M km2 14 English (US) 地球 北美洲AU 7.692M km2 9 English (AU) 地球 大洋洲 DataFrame的操作1df['Happiness Rank'] 结果： 123US 14AU 9Name: Happiness Rank, dtype: int64 对取出的数据进行操作 12345# 注意从DataFrame中取出的数据进行操作后，会对原始数据产生影响 ###注意copy和不copy的区别ranks = df['Happiness Rank']ranks += 2print(ranks)print(df) 结果： 123456US 16AU 11Name: Happiness Rank, dtype: int64 Area Happiness Rank Language Location RegionUS 9.834M km2 16 English (US) 地球 北美洲AU 7.692M km2 11 English (AU) 地球 大洋洲 对数据进行copy和非copy的之后的区别 123456# 注意从DataFrame中取出的数据进行操作后，会对原始数据产生影响# 安全的操作是使用copy()ranks = df['Happiness Rank'].copy()ranks += 2print(ranks)print(df) 结果： 123456US 18AU 13Name: Happiness Rank, dtype: int64 Area Happiness Rank Language Location RegionUS 9.834M km2 16 English (US) 地球 北美洲AU 7.692M km2 11 English (AU) 地球 大洋洲 索引操作总结 Pandas的索引可以归纳为3中： .loc,标签索引 .iloc,位置索引 （loc与iloc主要用于行索引） .ix，标签与位置混合索引（先按标签索引尝试操作，然后再按位置索引尝试操作） 注意： 121. DataFrame索引时可将其看作ndarray操作2. 标签的切片索引是包含末尾位置的 数据读取 pd.read_csv() index_col:指定索引列 usecols:指定需要读取的列 对于csv文档的基本操作 1234567# 加载csv文件数据report_2015_df = pd.read_csv('2015.csv')print('2015年数据预览：')#print(report_2015_df.head())report_2015_df.headreport_2015_df.head(5)report_2015_df.head() ##区别这三个的表达区别 1print(report_2015_df.info()) #查看相关数据 结果： 123456789101112131415161718&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;RangeIndex: 158 entries, 0 to 157Data columns (total 12 columns):Country 158 non-null objectRegion 158 non-null objectHappiness Rank 158 non-null int64Happiness Score 158 non-null float64Standard Error 158 non-null float64Economy (GDP per Capita) 158 non-null float64Family 158 non-null float64Health (Life Expectancy) 158 non-null float64Freedom 158 non-null float64Trust (Government Corruption) 158 non-null float64Generosity 158 non-null float64Dystopia Residual 158 non-null float64dtypes: float64(9), int64(1), object(2)memory usage: 14.9+ KBNone 对数据进行均值、方差等数据描述 1report_2015_df.describe() #对数据进行统计（每列） 查看末尾的数据 1report_2015_df.tail() #查看末尾的数据 索引对象IndexSeries和DataFrame中的索引都是Index对象 不可变(保证了数据的安全) 常见的Index种类 Index Int64Index MultiIndex，‘层次’索引 DatetimeIndex，时间戳类型 重置索引 reset_index()，将索引重新赋值为0-1 重命名列名：df.rename(columns = {old_col:new_col},inplace = True) 1234567# 使用index_col指定索引列# 使用usecols指定需要读取的列report_2016_df = pd.read_csv('./2016.csv', index_col='Country', usecols=['Country', 'Happiness Rank', 'Happiness Score', 'Region']) # ./是指本文件夹中# 数据预览report_2016_df.head() 打印列名和行名 12print('列名(column)：', report_2016_df.columns)print('行名(index)：', report_2016_df.index) 结果： 1234567列名(column)： Index([&apos;Region&apos;, &apos;Happiness Rank&apos;, &apos;Happiness Score&apos;], dtype=&apos;object&apos;)行名(index)： Index([&apos;Denmark&apos;, &apos;Switzerland&apos;, &apos;Iceland&apos;, &apos;Norway&apos;, &apos;Finland&apos;, &apos;Canada&apos;, &apos;Netherlands&apos;, &apos;New Zealand&apos;, &apos;Australia&apos;, &apos;Sweden&apos;, ... &apos;Madagascar&apos;, &apos;Tanzania&apos;, &apos;Liberia&apos;, &apos;Guinea&apos;, &apos;Rwanda&apos;, &apos;Benin&apos;, &apos;Afghanistan&apos;, &apos;Togo&apos;, &apos;Syria&apos;, &apos;Burundi&apos;], dtype=&apos;object&apos;, name=&apos;Country&apos;, length=157) index是不可以变的 12# 注意index是不可变的# report_2016_df.index[0] = '丹麦' #**可以自己运行尝试一下，目前被注释掉 index的重置 123# 重置index# 注意inplace加与不加的区别report_2016_df.reset_index(inplace=True) 1report_2016_df.head() 重命名列名 123# 重命名列名report_2016_df = report_2016_df.rename(columns=&#123;'Region': '地区', 'Hapiness Rank': '排名', 'Hapiness Score': '幸福指数'&#125;)report_2016_df.head() 123# 重命名列名，注意inplace的使用report_2016_df.rename(columns=&#123;'Region': '地区', 'Happiness Rank': '排名', 'Happiness Score': '幸 福指数'&#125;,inplace=True)report_2016_df.head() 注意并且重要：轴的方向 axis = 0 ，表示纵向计算（计算整行的数–每列每列） axis = 1 ，表示横向计算（计算整列的数–每行每行） Boolean Mask1report_2016_df.head() 123# 过滤 Western Europe 地区的国家# only_western_europe = report_2016_df['地区'] == 'Western Europe'report_2016_df[report_2016_df['地区'] == 'Western Europe'] 过滤数据 1234# 过滤 Western Europe 地区的国家# 并且排名在10之外only_western_europe_10 = (report_2016_df['地区'] == 'Western Europe') &amp; (report_2016_df['排名'] &gt; 10)only_western_europe_10 结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061620 False1 False2 False3 False4 False5 False6 False7 False8 False9 False10 False11 True12 False13 False14 False15 True16 False17 True18 True19 True20 False21 False22 True23 False24 False25 False26 False27 False28 False29 True ... 127 False128 False129 False130 False131 False132 False133 False134 False135 False136 False137 False138 False139 False140 False141 False142 False143 False144 False145 False146 False147 False148 False149 False150 False151 False152 False153 False154 False155 False156 FalseLength: 157, dtype: bool 叠加boolean mask得到结果 12# 叠加 boolean mask 得到最终结果report_2016_df[only_western_europe_10] 12# 熟练以后可以写在一行中report_2016_df[(report_2016_df['地区'] == 'Western Europe') &amp; (report_2016_df['排名'] &gt; 10)] 层级索引 MulitIndex对象 set_index([‘a’,’b’],inplace = True),注意a,b的先后顺序 选取子集 外层选取ser_obj.loc[‘outer_index’] 内层选取ser_obj.loc[‘out_index’,’inner_index’] 常用于分组操作、透视表的生产等 交换分层顺序 swaplevel() 排序分层 sort_index(level = ) 1report_2015_df.head() 设置层级索引 123# 设置层级索引report_2015_df2 = report_2015_df.set_index(['Region', 'Country','Happiness Rank']) #最好是赋给一个新的变量，保留原有的dataframe再进行操作report_2015_df2.head(20) 12# 只访西欧的国家，行索引，外层索引report_2015_df2.loc['Western Europe'] 内层索引 12# 内层索引report_2015_df2.loc['Western Europe', 'Switzerland'] 交换分层顺序 12# 交换分层顺序report_2015_df2.swaplevel().head(10) 12# 排序分层report_2015_df2.sort_index(level=2).head(10) #level = 0 就是0级索引，最外层顺序索引 数据清洗 是数据分析关键的一步，直接影响之后的处理工作 数据该如何调整才能适用于接下来的分析和挖掘 是一个迭代的过程，实际项目中可能需要不止一次地执行这些清洗操作 处理缺失数据 判断数据缺失，ser.obj.isnull(),df_obj.insull(),相反操作为notnull() 处理缺失数据 df.fillna(),df.dropna() df.ffill(),按之前的数据填充 df.bfill(),按之后的数据填充-项目中使用ffill或bfill时，注意数据的排列顺序 1234import pandas as pdlog_data = pd.read_csv('log.csv')log_data.head(10) #发现有很多空字符或者空值 判断数据是否缺失 123#判断数据是否缺失log_data.info()log_data.isnull().sum() 结果： 12345678910111213141516171819&lt;class 'pandas.core.frame.DataFrame'&gt;RangeIndex: 33 entries, 0 to 32Data columns (total 6 columns):time 33 non-null int64user 33 non-null objectvideo 33 non-null objectplayback position 33 non-null int64paused 3 non-null objectvolume 4 non-null float64dtypes: float64(1), int64(2), object(3)memory usage: 1.6+ KBtime 0user 0video 0playback position 0paused 30volume 29dtype: int64 查看缺失值 1log_data.isnull().head(10) #True表示缺失，False表示没有缺失 判断某一列是否缺失 1log_data['paused'].isnull().head(5) #判断某一列是否缺失 结果： 1234560 False1 True2 True3 True4 TrueName: paused, dtype: bool 数据过滤处理 12# 取出volume不为空的数据,数据过滤处理log_data[log_data['volume'].notnull()] 进行层级索引 123log_data.set_index(['time', 'user'], inplace=True) #进行层级索引，先时间戳再userlog_data.sort_index(inplace=True) #进行排序log_data.head(10) 填充缺失值 1log_data.fillna(0).head(10) #用0将缺失的值全部填充 #inplace = true就会让对原来数据产生影响 删除空数据 1log_data.dropna() #删除空数据 以上一个数据进行填充 1log_data.ffill().head(10) #按之前的数据填，指的就是上一个数据填 按之后的数据进行填充 1log_data.bfill().head(10) #按之后的数据填充 数据变形 处理重复数据 判断数据是否重复，duplicated() 去除重复数据，drop_duplicates()，可指定列及如何保留数据 使用函数或map转化数据，通常根据字典进行数据转化 替换值，replace() 离散化和分箱操作，put.cut(),返回Categorical对象 哑变量操作，pd.get_dummies() 向量化字符串操作 字符串列元素中是否包含子字符串，ser_obj.str.contains() 字符串列切片操作，ser_obj.str[a:b] 1234#处理重复数据data = pd.DataFrame(&#123;'k1': ['one', 'two'] * 3 + ['two'], 'k2': [1, 1, 2, 3, 3, 4, 4]&#125;)data 判断数据是否重复 12# 判断数据是否重复data.duplicated() 结果： 123456780 False1 False2 False3 False4 False5 False6 Truedtype: bool 去除重复数据 12# 去除重复数据data.drop_duplicates() 若col索引不存在会自动添加列索引以及值 12data['v1'] = range(7) #如果col的索引不存在会自动添加列索引以及值data 去除列的重复数据 12# 去除指定列的重复数据data.drop_duplicates(['k1']) 保持后面的那个数据 1data.drop_duplicates(['k1', 'k2'], keep='last') #通过两列去重复，keep指的是保持最后的那个数据 使用函数或map转换数据 1234#使用函数或map转化数据data = pd.DataFrame(&#123;'food': ['bacon', 'pulled pork', 'bacon', 'Pastrami', 'corned beef', 'Bacon', 'pastrami', 'honey ham', 'nova lox'], 'ounces': [4, 3, 12, 6, 7.5, 8, 3, 5, 6]&#125;)data 添加一列 123456789# 添加一列，用于指定食物的来源meat_to_animal = &#123; 'bacon': 'pig', 'pulled pork': 'pig', 'pastrami': 'cow', 'corned beef': 'cow', 'honey ham': 'pig', 'nova lox': 'salmon'&#125; 1234# 使用map()lowercased = data['food'].str.lower() #将food那列的数据的字符串全部转化为小写data['animal'] = lowercased.map(meat_to_animal) # 添加一列animal并将其数据用map函数对应data 使用匿名函数 123# 使用方法，使用lambdadata['animal2'] = data['food'].map(lambda x: meat_to_animal[x.lower()])data 用replace替换（将-999替换成为空值） 123#替换值replacedata = pd.Series([1., -999., 2., -999., -1000., 3.])data 结果： 12345670 1.01 -999.02 2.03 -999.04 -1000.05 3.0dtype: float64 1234import numpy as np# 将-999替换为空值data.replace(-999, np.nan) 结果： 12345670 1.01 NaN2 2.03 NaN4 -1000.05 3.0dtype: float64 将-999，-1000都替换为空值 12# 将-999，-1000都替换为空值data.replace([-999, -1000], np.nan) 结果： 12345670 1.01 NaN2 2.03 NaN4 NaN5 3.0dtype: float64 将-999，-1000分别替换为空值和0 12# 将-999，-1000分别替换为空值和0data.replace([-999, -1000], [np.nan, 0]) 结果： 12345670 1.01 NaN2 2.03 NaN4 0.05 3.0dtype: float64 用字典来数值替换 12#用字典来数值替换data.replace(&#123;-999: np.nan, -1000: 0&#125;) 结果： 12345670 1.01 NaN2 2.03 NaN4 0.05 3.0dtype: float64 离散化和分箱操作 1234567#离散化和分箱操作# 年龄数据ages = [20, 22, 25, 27, 21, 23, 37, 31, 61, 45, 41, 32]# 分箱的边界bins = [18, 25, 35, 60, 100] ##将年龄数据分到边界之内 #将数据离散化可以用到pandas的分箱操作 12cats = pd.cut(ages, bins)print(type(cats)) 1&lt;class &apos;pandas.core.categorical.Categorical&apos;&gt; Categorical对象 12# Categorical对象cats 结果： 123[(18, 25], (18, 25], (18, 25], (25, 35], (18, 25], ..., (25, 35], (60, 100], (35, 60], (35, 60], (25, 35]]Length: 12Categories (4, interval[int64]): [(18, 25] &lt; (25, 35] &lt; (35, 60] &lt; (60, 100]] 获取分箱编码 12# 获取分箱编码 #类别型特征处理的时候可以用分箱操作cats.codes 结果： 1array([0, 0, 0, 1, 0, 0, 2, 1, 3, 2, 2, 1], dtype=int8) 返回分箱边界索引 12# 返回分箱边界索引cats.categories 结果： 123IntervalIndex([(18, 25], (25, 35], (35, 60], (60, 100]] closed=&apos;right&apos;, dtype=&apos;interval[int64]&apos;) 统计箱中元素的个数 12# 统计箱中元素的个数pd.value_counts(cats) 结果： 12345(18, 25] 5(35, 60] 3(25, 35] 3(60, 100] 1dtype: int64 带标签的分箱 123# 带标签的分箱 #将分箱用名字来代替，类别型的特征group_names = ['Youth', 'YoungAdult', 'MiddleAged', 'Senior']cats = pd.cut(ages, bins, labels=group_names) 1cats.get_values() #获取数据的值 结果： 123array([&apos;Youth&apos;, &apos;Youth&apos;, &apos;Youth&apos;, &apos;YoungAdult&apos;, &apos;Youth&apos;, &apos;Youth&apos;, &apos;MiddleAged&apos;, &apos;YoungAdult&apos;, &apos;Senior&apos;, &apos;MiddleAged&apos;, &apos;MiddleAged&apos;, &apos;YoungAdult&apos;], dtype=object) 统计箱中元素的个数 12# 统计箱中元素的个数pd.value_counts(cats) #对值进行统计 结果： 12345Youth 5MiddleAged 3YoungAdult 3Senior 1dtype: int64 哑变量操作 1234#哑变量操作（sklearn里面是one-hot）df = pd.DataFrame(&#123;'key': ['b', 'b', 'a', 'c', 'a', 'b'], 'data1': range(6)&#125;)df 12#哑变量pd.get_dummies(df['key']) 向量化操作 1234#向量化操作data = &#123;'Dave': 'dave@google.com', 'Steve': 'steve@gmail.com', 'Rob': 'rob@gmail.com', 'Wes': np.nan&#125;data = pd.Series(data)data 结果： 12345Dave dave@google.comRob rob@gmail.comSteve steve@gmail.comWes NaNdtype: object 查看关键字 1data.str.contains('gmail') #关键字是否含有 结果： 12345Dave FalseRob TrueSteve TrueWes NaNdtype: object 取前5个数据 1data.str[:5] #取前5个数据 结果： 12345Dave dave@Rob rob@gSteve steveWes NaNdtype: object split操作 12split_df = data.str.split('@', expand=True) #expand默认是false，如果是true就分成两列split_df 进行合并 1split_df[0].str.cat(split_df[1], sep='@') #cat是将两个合并，通过@字符 结果： 12345Dave dave@google.comRob rob@gmail.comSteve steve@gmail.comWes NaNName: 0, dtype: object 数据合并及分组数据合并(pd.merge) 根据单个或多个键将不同DataFrame的行连接 默认将重叠列的列名作为‘外键’进行连接 on 显示指定’外键’ left_on ,左侧数据的’外键’ right_on,右侧数据的’外键’ 默认是’内连接(inner)，既结果中的键是交集 how指定连接方式 ‘外链接’（outer），结果中的键是并集 ‘左连接’（left） ‘右连接’（right） 处理重复列名 suffixes,默认为_x,_y 按索引连接 left_index =True 或 right_index = True 1234567891011121314import pandas as pdstaff_df = pd.DataFrame([&#123;'姓名': '张三', '部门': '研发部'&#125;, &#123;'姓名': '李四', '部门': '财务部'&#125;, &#123;'姓名': '赵六', '部门': '市场部'&#125;])student_df = pd.DataFrame([&#123;'姓名': '张三', '专业': '计算机'&#125;, &#123;'姓名': '李四', '专业': '会计'&#125;, &#123;'姓名': '王五', '专业': '市场营销'&#125;])print(staff_df)print()print(student_df) 结果： 123456789 姓名 部门0 张三 研发部1 李四 财务部2 赵六 市场部 专业 姓名0 计算机 张三1 会计 李四2 市场营销 王五 并集 123print(pd.merge(staff_df, student_df, how='outer', on = '姓名')) ##并集# 或者staff_df.merge(student_df, how='outer', on='姓名') 结果： 12345 姓名 部门 专业0 张三 研发部 计算机1 李四 财务部 会计2 赵六 市场部 NaN3 王五 NaN 市场营销 交集 123print(pd.merge(staff_df, student_df, how='inner', on='姓名')) #交集# 或者staff_df.merge(student_df, how='inner', on='姓名') 结果： 123 姓名 部门 专业0 张三 研发部 计算机1 李四 财务部 会计 左边数据是完整的 123print(pd.merge(staff_df, student_df, how='left', on='姓名')) #左边数据是完整的# 或者staff_df.merge(student_df, how='left', on='姓名') 结果： 1234 姓名 部门 专业0 张三 研发部 计算机1 李四 财务部 会计2 赵六 市场部 NaN 右边数据全完整 123pd.merge(staff_df, student_df, how='right', on='姓名') ##右边数据全有# 或者staff_df.merge(student_df, how='right', on='姓名') 按索引进行合并 12345# 也可以按索引进行合并staff_df.set_index('姓名', inplace=True)student_df.set_index('姓名', inplace=True)print(staff_df)print(student_df) 结果： 12345678910 部门姓名 张三 研发部李四 财务部赵六 市场部 专业姓名 张三 计算机李四 会计王五 市场营销 按第一个表格的索引合并 123print(pd.merge(staff_df, student_df, how='left', left_index=True, right_index=True))# 或者staff_df.merge(student_df, how='left', left_index=True, right_index=True) 结果： 12345 部门 专业姓名 张三 研发部 计算机李四 财务部 会计赵六 市场部 NaN 当数据中的列名不同时，使用left_on，right_on 12345# 当数据中的列名不同时，使用left_on，right_onstaff_df.reset_index(inplace=True)student_df.reset_index(inplace=True)print(staff_df)print(student_df) 结果： 12345678 姓名 部门0 张三 研发部1 李四 财务部2 赵六 市场部 姓名 专业0 张三 计算机1 李四 会计2 王五 市场营销 1234staff_df.rename(columns=&#123;'姓名': '员工姓名'&#125;, inplace=True)student_df.rename(columns=&#123;'姓名': '学生姓名'&#125;, inplace=True)print(staff_df)print(student_df) 结果： 12345678 员工姓名 部门0 张三 研发部1 李四 财务部2 赵六 市场部 学生姓名 专业0 张三 计算机1 李四 会计2 王五 市场营销 合并员工姓名和学生姓名 1pd.merge(staff_df, student_df, how='left', left_on='员工姓名', right_on='学生姓名') #合并员工姓名和学生姓名 当两个数据包含相同的列名，合并后会给列名加后缀加以区别 12345# 如果两个数据中包含有相同的列名（不是要合并的列）时，merge会自动加后缀作为区别staff_df['地址'] = ['天津', '北京', '上海']student_df['地址'] = ['天津', '上海', '广州']print(staff_df)print(student_df) 12345678 员工姓名 部门 地址0 张三 研发部 天津1 李四 财务部 北京2 赵六 市场部 上海 学生姓名 专业 地址0 张三 计算机 天津1 李四 会计 上海2 王五 市场营销 广州 1pd.merge(staff_df, student_df, how='left', left_on='员工姓名', right_on='学生姓名') #会自动加后缀区别 可以指定后缀名称 12# 也可指定后缀名称pd.merge(staff_df, student_df, how='left', left_on='员工姓名', right_on='学生姓名', suffixes=('(公司)', '(家乡)')) 也可以指定多列进行合并，找出同一个人的工作地址和家乡地址相同的记录 12# 也可以指定多列进行合并，找出同一个人的工作地址和家乡地址相同的记录pd.merge(staff_df, student_df, how='inner', left_on=['员工姓名', '地址'], right_on=['学生姓名', '地址']) 函数应用 可直接使用NumPy的ufunc函数，如abs等 通过apply将函数应用到行或列上 注意指定轴的方向，默认axis = 0 通过applymap将函数应用到每个数据上 apply的使用场景比applymap要多 123# apply使用# 获取姓staff_df['员工姓名'].apply(lambda x: x[0]) 结果： 12340 张1 李2 赵Name: 员工姓名, dtype: object 获取名字 12# 获取名staff_df['员工姓名'].apply(lambda x: x[1:]) 结果： 12340 三1 四2 六Name: 员工姓名, dtype: object 结果合并 1234# 结果合并staff_df.loc[:, '姓'] = staff_df['员工姓名'].apply(lambda x: x[0]) #:指行，逗号后面指列staff_df.loc[:, '名'] = staff_df['员工姓名'].apply(lambda x: x[1:])print(staff_df) 结果： 1234 员工姓名 部门 地址 姓 名0 张三 研发部 天津 张 三1 李四 财务部 北京 李 四2 赵六 市场部 上海 赵 六 分组（groupby） 对数据集进行分组，然后对每组进行统计分析 pandas能利用groupby进行更加复杂的分组运算 分组运算 split &gt; apply &gt; combine 拆分：进行分组的根据 应用：每个分组云U型的计算规则 合并：把每个分组的计算结果合并起来 123#读取数据report_data = pd.read_csv('./2015.csv')report_data.head() GroupBy对象：DataFrameGroupBy,SeriesGroupBy GroupBy对象没有进行实际运算，只是包含分组的中间数据 按列名分组，obj.groupby(‘label’) 按列名多层分组，obj.groupby([‘label1’,’label2’]) —-&gt;多层dataframe 123#groupby()grouped = report_data.groupby('Region') #region这一列进行分组print(type(grouped)) 结果： 1&lt;class &apos;pandas.core.groupby.DataFrameGroupBy&apos;&gt; 对GroupBy对象进行分组运算/多重分组运算，如mean() 非数值数据不进行分组运算 1grouped['Happiness Score'].mean() #分组里面，happiness的平均分 结果： 123456789101112RegionAustralia and New Zealand 7.285000Central and Eastern Europe 5.332931Eastern Asia 5.626167Latin America and Caribbean 6.144682Middle East and Northern Africa 5.406900North America 7.273000Southeastern Asia 5.317444Southern Asia 4.580857Sub-Saharan Africa 4.202800Western Europe 6.689619Name: Happiness Score, dtype: float64 size()返回每个分组的元素个数 1grouped.size() #分组里面的数量，比如澳大利亚和新西兰组里面有2个 结果： 123456789101112RegionAustralia and New Zealand 2Central and Eastern Europe 29Eastern Asia 6Latin America and Caribbean 22Middle East and Northern Africa 20North America 2Southeastern Asia 9Southern Asia 7Sub-Saharan Africa 40Western Europe 21dtype: int64 Groupby对象支持迭代操作 每次迭代返回一个元组(group_name,group_data) 可用于分组数据的具体运算 1234567# 迭代groupby对象for group, frame in grouped: #group相当于index mean_score = frame['Happiness Score'].mean() max_score = frame['Happiness Score'].max() min_score = frame['Happiness Score'].min() print('&#123;&#125;地区的平均幸福指数：&#123;&#125;，最高幸福指数：&#123;&#125;，最低幸福指数&#123;&#125;\n'.format(group, mean_score, max_score, min_score)) 结果： 12345678910111213141516171819Australia and New Zealand地区的平均幸福指数：7.285，最高幸福指数：7.2860000000000005，最低幸福指数7.284Central and Eastern Europe地区的平均幸福指数：5.332931034482757，最高幸福指数：6.505，最低幸福指数4.218Eastern Asia地区的平均幸福指数：5.626166666666666，最高幸福指数：6.297999999999999，最低幸福指数4.874Latin America and Caribbean地区的平均幸福指数：6.1446818181818195，最高幸福指数：7.226，最低幸福指数4.518Middle East and Northern Africa地区的平均幸福指数：5.406899999999999，最高幸福指数：7.278，最低幸福指数3.0060000000000002North America地区的平均幸福指数：7.273，最高幸福指数：7.4270000000000005，最低幸福指数7.119Southeastern Asia地区的平均幸福指数：5.317444444444444，最高幸福指数：6.797999999999999，最低幸福指数3.819Southern Asia地区的平均幸福指数：4.580857142857143，最高幸福指数：5.252999999999999，最低幸福指数3.575Sub-Saharan Africa地区的平均幸福指数：4.2028，最高幸福指数：5.477，最低幸福指数2.839Western Europe地区的平均幸福指数：6.689619047619048，最高幸福指数：7.587000000000001，最低幸福指数4.857 按自定义的函数分组 如果自定义函数，操作针对的是index 123456789101112131415161718# 自定义函数进行分组# 按照幸福指数排名进行划分，1-10, 10-20, &gt;20# 如果自定义函数，操作针对的是indexreport_data2 = report_data.set_index('Happiness Rank')print(report_data2.head(5))def get_rank_group(rank): rank_group = '' if rank &lt;= 10: rank_group = '0 -- 10' elif rank &lt;= 20: rank_group = '10 -- 20' else: rank_group = '&gt; 20' return rank_groupgrouped = report_data2.groupby(get_rank_group)for group, frame in grouped: print('&#123;&#125;分组的数据个数：&#123;&#125;'.format(group, len(frame))) 结果： 12345678910111213141516171819202122232425262728293031323334 Country Region Happiness Score Standard Error \Happiness Rank 1 Switzerland Western Europe 7.587 0.03411 2 Iceland Western Europe 7.561 0.04884 3 Denmark Western Europe 7.527 0.03328 4 Norway Western Europe 7.522 0.03880 5 Canada North America 7.427 0.03553 Economy (GDP per Capita) Family Health (Life Expectancy) \Happiness Rank 1 1.39651 1.34951 0.94143 2 1.30232 1.40223 0.94784 3 1.32548 1.36058 0.87464 4 1.45900 1.33095 0.88521 5 1.32629 1.32261 0.90563 Freedom Trust (Government Corruption) Generosity \Happiness Rank 1 0.66557 0.41978 0.29678 2 0.62877 0.14145 0.43630 3 0.64938 0.48357 0.34139 4 0.66973 0.36503 0.34699 5 0.63297 0.32957 0.45811 Dystopia Residual Happiness Rank 1 2.51738 2 2.70201 3 2.49204 4 2.46531 5 2.45176 0 -- 10分组的数据个数：1010 -- 20分组的数据个数：10&gt; 20分组的数据个数：138 实际项目中，通常可以先人为构造出一个分组列，然后再进行groupby12345678910# 实际项目中，通常可以先人为构造出一个分组列，然后再进行groupby# 按照score的整数部分进行分组# 按照幸福指数排名进行划分，1-10, 10-20, &gt;20# 如果自定义函数，操作针对的是indexreport_data['score group'] = report_data['Happiness Score'].apply(lambda score: int(score))grouped = report_data.groupby('score group')for group, frame in grouped: print('幸福指数整数部分为&#123;&#125;的分组数据个数：&#123;&#125;'.format(group, len(frame))) 结果： 123456幸福指数整数部分为2的分组数据个数：2幸福指数整数部分为3的分组数据个数：19幸福指数整数部分为4的分组数据个数：44幸福指数整数部分为5的分组数据个数：49幸福指数整数部分为6的分组数据个数：29幸福指数整数部分为7的分组数据个数：15 聚合（aggregation） grouped.agg(func),数组产生标量的过程，如mean(),count()等 常用于对分组后的数据进行计算 内置的聚合函数：sum(),mean(),max(),min(),count(),size(),describe() 可通过字典为每个列指定不同的操作方法 可自定义函数，传入agg方法中 123import numpy as np grouped.agg(&#123;'Happiness Score': np.mean, 'Happiness Rank': np.max&#125;) 求各种数值（mean，最大值，最小值，方差） 1grouped['Happiness Score'].agg([np.mean,np.amax,np.amin,np.std]) 透视表df.pivot_table(values,index,columns,aggfunc,margins) values:透视表中的元素值（根据聚合函数得出的） index:透视表的的行索引 columns:透视表的列索引 aggfunc:聚合函数，可以指定多个函数 margins:表示是否对所有数据进行统计 12345import pandas as pdimport numpy as npcars_df = pd.read_csv('cars.csv')cars_df.head() 通过计算平均值来比较 12# 我们想要比较不同年份的不同厂商的车，在电池方面的不同cars_df.pivot_table(values='(kW)', index='YEAR', columns='Make', aggfunc=np.mean) 通过多个聚合函数来对比 123# 我们想要比较不同年份的不同厂商的车，在电池方面的不同# 可以使用多个聚合函数cars_df.pivot_table(values='(kW)', index='YEAR', columns='Make', aggfunc=[np.mean, np.min]) 相关链接:源文件]]></content>
      <categories>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy]]></title>
    <url>%2F2018%2F07%2F09%2FNumpy%2F</url>
    <content type="text"><![CDATA[介绍Drew Conway认为数据科学包括：黑客技术： 如编程能力 向量化操作和算法思想 数学和统计知识 如常见的分布、最小二乘法 实质性的专业知识 数据科学设计到的操作 by David Donoho 数据探索与准备 数据操作、清洗等 数据展现形式与转化 不同格式的数据操作，表格型、图像、文本等 关于数据的计算 通过编程（python或R）计算分析数据 数据建模 预测、聚类等机器学习模型 数据可视化与展示 绘图、交互式、动画等 数据科学和涉及到的学科知识 何为数据分析 用适当的统计分析方法对收集来的大量数据进行分析，提取有用信息和形成结论对数据加以详细研究和概括总结的过程。 数据分析的目的 从数据中挖掘规律、验证猜想、进行预测 准备工作安装Anaconda链接：Anaconda Anaconda的安装教程 ps:安装anaconda的时候，把原有的python全部删了（否则会报错或者运行不了python3.x），然后安装的时候两个都勾选（务必确认勾选python添加到系统环境变量） 安装Pycharm链接：Pycharm ps:配置环境–&gt;project interpreter—&gt;选择anaconda中python的路径 链接：Anaconda常用命令大全 Python进阶技巧条件表达式列表推导式字典推导式123456789101112131415161718192021#条件表达式import mathdef get_log(x): ''' 计算log函数 ''' log_v = math.log(x) if x&gt;0 else float('nan') return log_vprint (get_log(5))print (get_log(-1))print('---------分割线-------')#列表推导式l1 = [i for i in range(1,100) if i%2 ==0]print(l1)print('---------分割线-------')#字典推导式D = &#123;x.upper(): x*3 for x in 'abcd'&#125;print(D) 结果： 1234561.6094379124341003nan---------分割线-------[2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98]---------分割线-------&#123;'A': 'aaa', 'B': 'bbb', 'C': 'ccc', 'D': 'ddd'&#125; Python常用的容器类型（list 、set、dictionary、tuple）ps：列表、集合、字典以及元组的详细基础知识见python基础，这里讲基础没有涉及的函数以及方法。 list(列表） 1234567891011121314151617181920212223242526272829303132l = [1, 'a', 2, 'b']print(type(l))print('修改前：', l)# 修改list的内容l[0] = 3print('修改后：', l)# 末尾添加元素l.append(4)print('添加后：', l)# 遍历listprint('遍历list(for循环)：')for item in l: print(item) # 通过索引遍历listprint('遍历list(while循环)：')i = 0while i != len(l): print(l[i]) i += 1 # 列表合并print('列表合并(+)：', [1, 2] + [3, 4])# 列表重复print('列表重复(*)：', [1, 2] * 5)# 判断元素是否在列表中print('判断元素存在(in)：', 1 in [1, 2]) 结果： 12345678910111213141516171819&lt;class 'list'&gt;修改前： [1, 'a', 2, 'b']修改后： [3, 'a', 2, 'b']添加后： [3, 'a', 2, 'b', 4]遍历list(for循环)：3a2b4遍历list(while循环)：3a2b4列表合并(+)： [1, 2, 3, 4]列表重复(*)： [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]判断元素存在(in)： True tuple(元组） 12345678910111213141516171819202122232425262728293031323334353637383940t = (1, 'a', 2, 'b')print(type(t))#元组的内容不能修改，否则会报错# t[0] = 3 # 遍历tupleprint('遍历list(for循环)：')for item in t: print(item) # 通过索引遍历tupleprint('遍历tuple(while循环)：')i = 0while i != len(t): print(t[i]) i += 1 # 解包 unpack(就是将元祖解开并一一对应)a, b, c,_ = tprint('unpack: ', a)# 确保unpack接收的变量个数和tuple的长度相同，否则报错# 经常出现在函数返回值的赋值时# a, b, c = timport struct #pack - unpack print print ('===== pack - unpack =====') str = struct.pack("ii", 20, 400) ##将数据放进内存里面包装起来print ('str:', str) print ('len(str):', len(str)) # len(str): 8 a1, a2 = struct.unpack("ii", str) ##从内存中把数据提取出来print ("a1:", a1) # a1: 20 print ("a2:", a2) # a2: 400 print ('struct.calcsize:', struct.calcsize("ii")) # struct.calcsize: 8 结果： 123456789101112131415161718&lt;class 'tuple'&gt;遍历list(for循环)：1a2b遍历tuple(while循环)：1a2bunpack: 1===== pack - unpack =====str: b'\x14\x00\x00\x00\x90\x01\x00\x00'len(str): 8a1: 20a2: 400struct.calcsize: 8 dictionary（字典） 12345678910111213141516171819202122232425d = &#123;'百度': 'https://www.baidu.com/', '阿里巴巴': 'https://www.alibaba.com/', '腾讯': 'https://www.tencent.com/'&#125;print('通过key获取value: ', d['百度'])# 遍历keyprint('遍历key: ')for key in d.keys(): print(key) # 遍历valueprint('遍历value: ')for value in d.values(): print(value) # 遍历itemprint('遍历item: ')for key, value in d.items(): print(key + ': ' + value)# format输出格式print('format输出格式：')for key, value in d.items(): print('&#123;&#125;的网址是&#123;&#125;'.format(key, value)) 结果 1234567891011121314151617通过key获取value: https://www.baidu.com/遍历key: 百度阿里巴巴腾讯遍历value: https://www.baidu.com/https://www.alibaba.com/https://www.tencent.com/遍历item: 百度: https://www.baidu.com/阿里巴巴: https://www.alibaba.com/腾讯: https://www.tencent.com/format输出格式：百度的网址是https://www.baidu.com/阿里巴巴的网址是https://www.alibaba.com/腾讯的网址是https://www.tencent.com/ set（集合） 12345678910111213141516171819#创建集合print('创建set:')my_set = &#123;1, 2, 3&#125;print(my_set)my_set = set([1, 2, 3, 2])print(my_set)#添加集合的元素，添加在最后print('添加单个元素:')my_set.add(3)print('添加3', my_set)my_set.add(4)print('添加4', my_set)#添加多个元素print('添加多个元素：')my_set.update([4, 5, 6])print(my_set) 结果： 12345678创建set:&#123;1, 2, 3&#125;&#123;1, 2, 3&#125;添加单个元素:添加3 &#123;1, 2, 3&#125;添加4 &#123;1, 2, 3, 4&#125;添加多个元素：&#123;1, 2, 3, 4, 5, 6&#125; Counter（类似于数学中的多重集）链接：Counter 初始化 （会按照从多到少排列） 123456789import collectionsc1 = collections.Counter(['a', 'b', 'c', 'a', 'b', 'b'])c2 = collections.Counter(&#123;'a':2, 'b':3, 'c':1&#125;)c3 = collections.Counter(a=2, b=3, c=1)print(c1)print(c2)print(c3) 结果： 123Counter(&#123;'b': 3, 'a': 2, 'c': 1&#125;)Counter(&#123;'b': 3, 'a': 2, 'c': 1&#125;)Counter(&#123;'b': 3, 'a': 2, 'c': 1&#125;) update() 更新内容，注意是做“加法”，不是“替换” 123# 注意这里是做“加法”，不是“替换”c1.update(&#123;'a': 4, 'c': -2, 'd': 4&#125;)print(c1) 结果： 1Counter(&#123;'a': 6, 'd': 4, 'b': 3, 'c': -1&#125;) 访问内容[key] 注意和dict的区别：如果Counter中不存在key值，返回0；而dict会报错 1234print('a=', c1['a'])print('b=', c1['b'])# 对比和dict的区别print('e=', c1['e']) 结果： 123a= 6b= 3e= 0 element()方法 12for element in c1.elements(): print(element) 结果： 12345678910111213aaaaaabbbdddd most_common()方法，返回前n多的数据（比如，在词频统计中，只要求最多的前三个） 1c1.most_common(3) 结果： 1[('a', 6), ('d', 4), ('b', 3)] defaultdict 在Python中如果访问字典里不存在的键，会出现KeyError异常。有些时候，字典中每个键都存在默认值是很方便的 defaultdict是Python内建dict类的一个子类，第一个参数为default_factory属性提供初始值，默认为None。它覆盖一个方法并添加一个可写实例变量。它的其他功能与dict相同，但会为一个不存在的键提供默认值，从而避免KeyError异常。 链接：defaultdict 12345# 统计每个字母出现的次数s = 'chinadoop'# 使用Counterprint(collections.Counter(s)) 结果： 1Counter(&#123;'o': 2, 'c': 1, 'h': 1, 'i': 1, 'n': 1, 'a': 1, 'd': 1, 'p': 1&#125;) 使用dict： 123456789# 使用dictcounter = &#123;&#125;for c in s: if c not in counter: #初始化成1 counter[c] = 1 else: counter[c] += 1 print(counter.items()) 结果： 1dict_items([('c', 1), ('h', 1), ('i', 1), ('n', 1), ('a', 1), ('d', 1), ('o', 2), ('p', 1)]) 使用defaultdict 12345# 使用defaultdictcounter2 = collections.defaultdict(int) #int初始化成一个整型的空值，就是0for c in s: counter2[c] += 1print(counter2.items()) 结果： 1dict_items([('c', 1), ('h', 1), ('i', 1), ('n', 1), ('a', 1), ('d', 1), ('o', 2), ('p', 1)]) 记录相同元素的列表 1234567# 记录相同元素的列表colors = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]d = collections.defaultdict(list) #list代表，字典里面的值默认的是空的列表for k, v in colors: d[k].append(v)print(d.items()) 结果： 1dict_items([('yellow', [1, 3]), ('blue', [2, 4]), ('red', [1])]) map()函数 map(function,sequence) 可用于数据清洗 12345678910111213141516import mathprint('示例1，获取两个列表对应位置上的最小值：') # map就是做映射l1 = [1, 3, 5, 7, 9]l2 = [2, 4, 6, 8, 10]mins = map(min, l1, l2) #只用map的话，只是建立这一种计算，并没有执行，建立一个map objectprint(mins) print('-----分割线--------') # map()函数操作时，直到访问数据时才会执行for item in mins: #通过遍历来访问数据才会执行 print(item)print('-----分割线--------')print('示例2，对列表中的元素进行平方根操作：')squared = map(math.sqrt, l2)print(squared)print(list(squared)) 结果： 123456789101112示例1，获取两个列表对应位置上的最小值：&lt;map object at 0x000002B8D0A2D400&gt;-----分割线--------13579-----分割线--------示例2，对列表中的元素进行平方根操作：&lt;map object at 0x000002B8D0A2D080&gt;[1.4142135623730951, 2.0, 2.449489742783178, 2.8284271247461903, 3.1622776601683795] 匿名函数lambda 简单的函数操作 返回值是func类型 可结合map()完成数据清洗操作 12345678910my_func = lambda a, b, c: a * b #返回值是一个函数类型 functionprint(my_func)print(my_func(1, 2, 3))print('------分割线----------')# 结合mapprint('lambda结合map：')l1 = [1, 3, 5, 7, 9]l2 = [2, 4, 6, 8, 10]result = map(lambda x, y: x * 2 + y, l1, l2) #为了提高效率，尽量不用for循环（x,y是传入的参数，冒号后面是函数体）print(list(result)) 结果： 12345&lt;function &lt;lambda&gt; at 0x000002B8CF089F28&gt;2------分割线----------lambda结合map：[4, 10, 16, 22, 28] 科学计算库NumPy（Numerical Python） 高性能科学计算和数据分析的基础包，提供多维数组对象 ndarray，多维数组（矩阵），具有矢量运算能力，快速、节省空间 矩阵运算，无需循环，可完成类似Matlab中的矢量运算 线性代数、随机数生成 import numpy as np链接： numpy_api 注： Scipy也是科学计算库 在Numpy库的基础上增加了众多的数学、科学及工程常用的库函数 线性代数、常微分方程求解、信号处理、图像处理、稀疏矩阵等 import scipy as sp ndarray， N维数组对象（矩阵） nidm属性，维度个数 shape属性，各维度大小 dtype属性，数据类型 123456import numpy as npm = np.array([[2,3,4],[2,3,4],[3,4,5],[6,7,8]])print(m) print(m.shape) # 4行3列的数组 ，列方向上维度是4，行方向上维度是3print(m.ndim) # 维度是2个维度print(m.dtype) # 类型是整数型 结果： 1234567[[2 3 4] [2 3 4] [3 4 5] [6 7 8]](4, 3)2int32 创建ndarray np.array(collection),collection为序列型对象（list）,嵌套序列（list of list） np.zeros,np.ones,np.empty指定大小的全0或全1数组 注意：第一个参数是元组，用来指定大小，如（3,4） empty不是总是返回全0，有时返回的是未初始的随机值 1234567891011import numpy as np# 创建arraymy_list = [1, 2, 3]x = np.array(my_list)print('列表：', my_list)print('Array: ', x)print(x.shape) #维度的大小，这里指在这个维度上，维度的大小是3print(x.ndim) # 维度是1个维度print(x.dtype) # 类型是整数型 结果： 12345列表： [1, 2, 3]Array: [1 2 3](3,)1int32 array的运算 12#array的运算np.array([1, 2, 3]) -np.array([4, 5, 6]) 结果： 1array([-3, -3, -3]) 建立ndarray数据，第三个参数是步长（step） 12345678#建立ndarray数据，第三个参数是步长（step）n = np.arange(0, 30, 2)print(n)print('-----------分割----------')# reshape的用法，比较重要n = n.reshape(3, 5)print('reshape后: ')print(n) 结果： 123456[ 0 2 4 6 8 10 12 14 16 18 20 22 24 26 28]-----------分割----------reshape后: [[ 0 2 4 6 8] [10 12 14 16 18] [20 22 24 26 28]] 单位矩阵等初始化 1234567print('ones:\n', np.ones((3, 2)))print('zeros:\n', np.zeros((3, 2)))print('eye:\n', np.eye(3))print('diag:\n', np.diag(my_list))print('-----分割---------')a = np.zeros((3,4),dtype = int) #第一个参数是元组，用来指定大小，dtype用来指定数据类型,empty慎用print(a) 结果： 1234567891011121314151617181920ones: [[ 1. 1.] [ 1. 1.] [ 1. 1.]]zeros: [[ 0. 0.] [ 0. 0.] [ 0. 0.]]eye: [[ 1. 0. 0.] [ 0. 1. 0.] [ 0. 0. 1.]]diag: [[1 0 0] [0 2 0] [0 0 3]]-----分割---------[[0 0 0 0] [0 0 0 0] [0 0 0 0]] repeat和*的区别 123# repeat和*的区别print('*操作：\n', np.array([1, 2, 3] * 3))print('repeat：\n', np.repeat([1, 2, 3], 3)) 结果： 1234*操作： [1 2 3 1 2 3 1 2 3]repeat： [1 1 1 2 2 2 3 3 3] 矩阵的叠加 1234567p1 = np.ones((3, 3))print(p1)print('-------分割----------')p2 = np.arange(9).reshape(3, 3)print(p2)print('纵向叠加: \n', np.vstack((p1, p2)))print('横向叠加: \n', np.hstack((p1, p2))) 结果： 123456789101112131415161718[[ 1. 1. 1.] [ 1. 1. 1.] [ 1. 1. 1.]]-------分割----------[[0 1 2] [3 4 5] [6 7 8]]纵向叠加: [[ 1. 1. 1.] [ 1. 1. 1.] [ 1. 1. 1.] [ 0. 1. 2.] [ 3. 4. 5.] [ 6. 7. 8.]]横向叠加: [[ 1. 1. 1. 0. 1. 2.] [ 1. 1. 1. 3. 4. 5.] [ 1. 1. 1. 6. 7. 8.]] 3.3 Array操作1234567print('p1: \n', p1) #p1和p2都引用了上面p1和p2print('p2: \n', p2)print('p1 + p2 = \n', p1 + p2) #对两个数组进行四则运算操作print('p1 * p2 = \n', p1 * p2)print('p2^2 = \n', p2 ** 2)print('p1.p2 = \n', p1.dot(p2)) 结果： 123456789101112131415161718192021222324p1: [[ 1. 1. 1.] [ 1. 1. 1.] [ 1. 1. 1.]]p2: [[0 1 2] [3 4 5] [6 7 8]]p1 + p2 = [[ 1. 2. 3.] [ 4. 5. 6.] [ 7. 8. 9.]]p1 * p2 = [[ 0. 1. 2.] [ 3. 4. 5.] [ 6. 7. 8.]]p2^2 = [[ 0 1 4] [ 9 16 25] [36 49 64]]p1.p2 = [[ 9. 12. 15.] [ 9. 12. 15.] [ 9. 12. 15.]] 转换数组类型(astype) 1234567#数组的转置p3 = np.arange(6).reshape(2, 3)print('p3形状: ', p3.shape)print(p3)p4 = p3.Tprint('转置后p3形状: ', p4.shape)print(p4) 结果： 1234567p3形状: (2, 3)[[0 1 2] [3 4 5]]转置后p3形状: (3, 2)[[0 3] [1 4] [2 5]] 数据类型的查看以及对数据类型的转换（astype） 1234567#数据类型的查看以及对数据类型的转换（astype）print('p3数据类型:', p3.dtype)print(p3)p5 = p3.astype('float')print('p5数据类型:', p5.dtype)print(p5) 结果： 123456p3数据类型: int32[[0 1 2] [3 4 5]]p5数据类型: float64[[ 0. 1. 2.] [ 3. 4. 5.]] 对于数据基本的操作，比如求和，最小最大，平均，方差等 1234567891011#对于数据基本的操作，比如求和，最小最大，平均，方差等a = np.array([-5,-3,-2 , -6, 3, 5])print('sum: ', a.sum())print('min: ', a.min())print('max: ', a.max())print('mean: ', a.mean())print('std: ', a.std())print('argmax: ', a.argmax()) #返回最大值所在的index（索引值）print('argmin: ', a.argmin()) #返回最小值所在的index（索引值）#提示：注意多维的话，要指定统计的维度，否则默认是全部维度上做统计 结果： 1234567sum: -8min: -6max: 5mean: -1.33333333333std: 4.0276819912argmax: 5argmin: 3 索引与切片 一维数组的索引与Python的列表索引功能相似 多维数组的索引 arr[r1:r2, c1:c2] arr[1,1]等价arr[1][1] [:]代表某个维度的数据 12345678# 一维arrays = np.arange(13) ** 2print('s: ', s)print('s[0]: ', s[0])print('s[4]: ', s[4])print('s[0:3]: ', s[0:3])print('s[[0, 2, 4]]: ', s[[0, 2, 4]]) print('s[0:9:4]:',s[0:9:4]) #第三个参数是步长 结果： 123456s: [ 0 1 4 9 16 25 36 49 64 81 100 121 144]s[0]: 0s[4]: 16s[0:3]: [0 1 4]s[[0, 2, 4]]: [ 0 4 16]s[0:9:4]: [ 0 16 64] 二维array 12345# 二维arrayr = np.arange(36).reshape((6, 6))print('r: \n', r)print('r[2, 2]: \n', r[2, 2])print('r[3, 3:6]: \n', r[3, 3:6]) #第三行的，index3、4、5的值 结果： 1234567891011r: [[ 0 1 2 3 4 5] [ 6 7 8 9 10 11] [12 13 14 15 16 17] [18 19 20 21 22 23] [24 25 26 27 28 29] [30 31 32 33 34 35]]r[2, 2]: 14r[3, 3:6]: [21 22 23] 条件索引 布尔值多维数组 arr[condition]condition可以是多个条件组合 注意，多个条件组合要使用&amp; |，而不是and or 以上是根据条件将数据转换成布尔型true和false的情况，然后再把true所对应的值取出来。 1r &gt; 30 #引用上面的r的数组 数据类型：bool（布尔型） 结果： 123456array([[False, False, False, False, False, False], [False, False, False, False, False, False], [False, False, False, False, False, False], [False, False, False, False, False, False], [False, False, False, False, False, False], [False, True, True, True, True, True]], dtype=bool) 数据的过滤 123456# 过滤print(r[r &gt; 30]) #将大于30的取出来# 将大于30的数赋值为30r[r &gt; 30] = 30 print(r) 结果： 1234567[31 32 33 34 35][[ 0 1 2 3 4 5] [ 6 7 8 9 10 11] [12 13 14 15 16 17] [18 19 20 21 22 23] [24 25 26 27 28 29] [30 30 30 30 30 30]] array的拷贝操作 arr1 = arr2 arr1内数据的更改会影响arr2 建议使用arr1 = arr2.copy()，这样就不会互相影响 123# copy()操作 #仍然引用上面的r数组r2 = r[:3, :3]print(r2) 结果： 123[[ 0 1 2 [ 6 7 8] [12 13 14]] 对r2赋值，查看对原数组是否会影响 12345# 将r2内容设置为0r2[:] = 0# 查看r的内容 print(r) #可以看出r2的改变，是会对r有影响的 结果： 123456[[ 0 0 0 3 4 5] [ 0 0 0 9 10 11] [ 0 0 0 15 16 17] [18 19 20 21 22 23] [24 25 26 27 28 29] [30 30 30 30 30 30]] 通过copy操作后对r3赋值，查看对原数组是否有影响 12345r3 = r.copy() #对r进行copy操作----&gt;r3r3[:] = 0print(r)print('-------分割----------')print(r3) #可以观察出r3的修改对原来的r没有影响 结果： 12345678910111213[[ 0 0 0 3 4 5] [ 0 0 0 9 10 11] [ 0 0 0 15 16 17] [18 19 20 21 22 23] [24 25 26 27 28 29] [30 30 30 30 30 30]]-------分割----------[[0 0 0 0 0 0] [0 0 0 0 0 0] [0 0 0 0 0 0] [0 0 0 0 0 0] [0 0 0 0 0 0] [0 0 0 0 0 0]] 遍历Array12t = np.random.randint(0, 10, (4, 3)) #0-10随机一个4行3列的数组print(t) 结果： 1234[[5 1 9] [2 5 1] [3 7 9] [4 8 1]] 遍历每行操作 12for row in t: #遍历每行 print(row) 结果： 1234[5 1 9][2 5 1][3 7 9][4 8 1] 使用enumerate() 123# 使用enumerate()for i, row in enumerate(t): print('row &#123;&#125; is &#123;&#125;'.format(i, row)) 结果： 1234row 0 is [5 1 9]row 1 is [2 5 1]row 2 is [3 7 9]row 3 is [4 8 1] 将所有数据平方 12t2 = t ** 2 #将数据全部平方print(t2) 结果： 1234[[25 1 81] [ 4 25 1] [ 9 49 81] [16 64 1]] 使用zip对两个array进行遍历计算 123# 使用zip对两个array进行遍历计算for i, j in zip(t, t2): #zip就是将列 print('&#123;&#125; + &#123;&#125; = &#123;&#125;'.format(i, j, i + j)) 结果： 1234[5 1 9] + [25 1 81] = [30 2 90][2 5 1] + [ 4 25 1] = [ 6 30 2][3 7 9] + [ 9 49 81] = [12 56 90][4 8 1] + [16 64 1] = [20 72 2] 取出唯一值 123a = list([1,1,1,1,1,2,2,2,2,3,3,3,4]) #取出唯一的值b = np.unique(a)print(b) 结果： 1[1 2 3 4] 相关链接：源文件]]></content>
      <categories>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
        <tag>Python进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习数学基础(一)]]></title>
    <url>%2F2018%2F07%2F09%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[写在前面:函数 函数与数据的泛化 推理与归纳 线性代数 向量与矩阵 特征值与特征空间 高维空间向量 特征向量 函数定义：在数学中，函数(function)就是一种关系，是一组输入和一组输出之间的关系，也是映射。 类型 1.2.1指数函数(常用作激活函数) $$y = e^x$$应用链接：动态模型展示链接 1.2.2 对数函数(指数函数的反函数) 1.2.3 sigmoid函数(一般用作激活函数:因为映射到（0,1）之间) $$S(x) = \frac{1}{1+e^{-x}} = \frac{e}{e^x+1}$$ 线性整流函数(常用的为斜坡函数：rectifier) $$f(x) = max(0,x)$$当 x &gt; 0 时，x = y当 x &lt; 0 时，y = 0 链接：线性整流函数函数 复合函数（函数的嵌套,Function Decomposition） 举例：$$f(x) = 2x+3$$ $$f(f(x)) = 2(2x+3)+3 = 4x + 9$$ 动态函数和静态函数 上面为静态函数，下面为动态函数区别：动态函数的输入是和时间有关系，静态函数的输入则和时间没有关系 比较接近现实的函数(The Real-World Data) 凸函数(Convex Set and Function) 如上图左，t为权重，相当于x，y都属于在0和1之间。上图右，满足公式的条件就是凸函数。 线性代数(Linear Algebra)向量(Vector)是一个有方向的标量 向量空间(vector space)欧几里德空间(Euclidean space)被数学代表着物理空间和概念，比如，长宽高，角度等。用的笛卡尔坐标系来表示。$$\begin{pmatrix} 1 \ 2 \end{pmatrix}$$ 上面是二维向量空间$$\left(\begin{matrix}1\2\3\\end{matrix}\right)$$上面是三维向量空间 向量的模(Norm of Vectors)，向量的范数$$\parallel x \parallel$$ 为向量X的范数，$$[V;\parallel \cdot \parallel ]$$为赋范空间 公理：$$\parallel X\parallel \geq 0$$ $$\parallel \alpha{X}\parallel = \mid\alpha\mid{\parallel X \parallel}$$ $$\parallel X+Y \parallel \leq \parallel X \parallel + \parallel Y \parallel$$ 范数(L-0 TO L-infinity)链接：范数 L-0范数 指向量中非0的元素的个数，如果用L0范数来规则化一个参数矩阵W的话，就是希望W的大部分元素都是0，意思就是让参数W是稀疏的。但是实际上我们更多是用是L1范数来实现稀疏，因为L1范数的最有凸近似，而且比L0范数要容易优化求解。总之，L1范数和L0范数都可以实现稀疏，L1因具有比L0更好的优化求解特性而被广泛应用。 例子：$$\begin{pmatrix} 1 \ 2\end{pmatrix} \Rightarrow 2 \quad\text{说明非零的个数有两个}$$ $$\begin{pmatrix} 1 \ 0\end{pmatrix} \Rightarrow 1\quad\text{说明非零的个数只有1个}$$ L-1范数和L-2范数 L-1norm是两点之间的距离，也称曼哈顿距离(Mahatten Distance)，即在欧几里德空间的固定指教坐标系上两点所形成的线段对轴产生的投影的距离总和 L-2norm是欧几里德距离(Euclidean Distance),也叫欧氏距离，表示在m维空间中两个点之间的距离 转自：参考链接 在正则化中二者的区别： 下图是表示曼哈顿距离和欧几里德距离的直观图，曼哈顿距离可能有多解 归纳总结：$$\parallel x \parallel_p = (\sum_{i = 1}^n {\mid x_i\mid}^p)^\frac{1}{p}$$所以当$$n = \infty$$则公式为$$\parallel x \parallel_\infty = (\sum_{i = 1}^n {\mid x_i\mid}^\infty)^\frac{1}{\infty}$$ $$\Rightarrow \sqrt[\infty]{\sum_{i=1}^n \mid X_i\mid^{\infty} }$$ 假设存在一个条件：$$max(x_1,x_2,x_3,\cdots,x_n) =x_j$$ $$x_j\text{里面最大的一个值}$$ $$\because x_j^\infty &gt;&gt; x_i^\infty$$ $$\parallel x \parallel_\infty = (\sum_{i = 1}^n {\mid x_i\mid}^\infty)^\frac{1}{\infty} \Rightarrow \mid x_j \mid$$ 下面是综合的图： 矩阵(Matrix)向量可以看作是特殊的矩阵，是一个一维矩阵。(dimensions = 1)欧美的习惯，A表示列矩阵，例如：$$A = \begin{bmatrix} a_1 \a_2\a_3\end{bmatrix}$$ $$A^T = \begin{bmatrix} a_1&amp; a_2&amp;a_3\end{bmatrix}$$ $$\text{说明：}A^T\text{是}A\text{的转置矩阵}$$ 张量(Tensor)链接：中文链接，英文链接 张量这个词最早来自于物理。张量是在标量和向量的基础之上做的进一步推广。 在一个三维的坐标系中，我们可以用三维的向量来表示压力的大小和方向，与此同时我们还需要表示出压力作用的切平面，切平面同样可以用其法向量（垂直于切平面的向量）来表示出来。这种物理量就存在两个方向（力的方向和受力表面的方向），就是一个二阶的张量。实际上标量就是0阶张量，而向量则是一阶张量。 实际上你需要记住的只有一点，在进行张量运算的时候，经常把张量当成多维数组进行计算。 行列式(Determinant)行列式就是矩阵的值。表示可以为：$$det(A)$$ $$detA$$ $$\mid A\mid$$ 以上都是行列式的表达方式。行列式也可以看作矩阵组成的面积。 特征向量(Eigenvector)和特征值(Eigenvalue)链接：demonstration展示链接$$\text{设矩阵A是n阶矩阵，如果数}\lambda\text{和n维非零向量x使关系式}$$ $$Ax = \lambda x$$ $$\text{成立，那么，这样的数}\lambda\text{成为矩阵A的特征值，非零向量x称为A的对应于特征值}\lambda\text{的特征向量。}$$ 奇异值分解（SVD:Singular Value Decomposition）把一个矩阵分成三个矩阵的乘积，其中有一个矩阵是对角矩阵。如下图： 雅可比矩阵和海森矩阵(Jacobian and Hessian Matrices)链接：Jacobian，Hessian 在向量分析中，雅可比矩阵是函数的一阶偏导数以一定方式排列成的矩阵，其行列式称为雅可比行列式。 在数学中，海森矩阵（Hessian matrix 或 Hessian）是一个多变量实值函数的二阶偏导数组成的方块矩阵。 参考资料(对于机器学习够用，而且比较全面): 黄博高等数学公式总结：高等数学 黄博的线性代数总结：线性代数]]></content>
      <categories>
        <category>机器学习</category>
        <category>数学基础</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>数学</tag>
        <tag>函数</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python(十)]]></title>
    <url>%2F2018%2F07%2F09%2FPython-%E5%8D%81%2F</url>
    <content type="text"><![CDATA[微信用户数据分析微信接口itchat 第三方开源的微信个人接口 安装方法：pip install itchat 用户数据分析指标 不同性别好友人数和占比 实例1： 1234567891011121314151617181920212223242526'''功能：微信好友性别分析报表'''import itchatdef wechat_user_gender_report(): itchat.login() friends = itchat.get_friends() male_count = 0 female_count = 0 other_count = 0 for friend in friends[1:]: gender = friend["Sex"] if gender == 1: male_count += 1 elif gender == 2: female_count += 1 else: other_count += 1 total = len(friends[1:]) #含有总数 print("------------*微信好友分析报告*----------------") print("好友总数：&#123;&#125;".format(total)) print("男性好友数：%d，占比：%.2f%%"%(male_count,float(male_count)/total*100)) print("女性好友数：%d，占比：%.2f%%"%(female_count,float(female_count)/total*100)) print("未知性别好友数：%d，占比：%.2f%%" % (other_count, float(other_count) / total * 100))wechat_user_gender_report() 不同地域用户分布情况 实例2： 123456789101112131415161718'''功能：微信好友地域分布分析报表'''import itchatdef wechat_user_location_report(): itchat.login() friends = itchat.get_friends() province_dict = &#123;&#125; for friend in friends[1:]: province = friend["Province"] if province == "": province = "未知" else: province_dict[province] = province_dict.get(province,0) + 1 print(province_dict)wechat_user_location_report() 绘图库matplotlib Python的2D绘图库，可以绘制常用的直方图，折线图，散点图等 安装方法：pip install matplotlib 链接：matplotlib官方 实例3： 123456789101112131415161718192021222324'''功能：根据数据生成饼图参数说明： datas：展示的数据列表 labels：展示的数据标签'''def get_pie(self,datas,labels): #设置字符集 plt.rcParams["font.sans-serif"] = ["SimHei"] ##设置字符集 plt.figure(figsize=(8,6),dpi=80) #创建图形的size(像素点)，并且设置分辨率（dpi） plt.axes(aspect= 1) #设置x轴和y轴的比例 plt.pie(datas,labels=labels,autopct="%.2f%%",shadow=False) # 设置饼图 plt.title("微信好友性别分析图") plt.show()def get_bar(self,datas,labels): # 设置字符集 plt.rcParams["font.sans-serif"] = ["SimHei"] plt.xlabel("province") plt.ylabel("count") plt.xticks(range(len(datas)),labels) plt.bar(range(len(datas)),datas,color="rgb") plt.title("微信好友地域分布图") plt.show()]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>微信接口itchat</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python(九)]]></title>
    <url>%2F2018%2F07%2F09%2FPython-%E4%B9%9D%2F</url>
    <content type="text"><![CDATA[冒泡排序原理： 循环遍历列表，每次循环找出本次循环最大的元素排在后边 需要使用嵌套循环实现，外层循环控制总循环次数，内存循环负责每轮的循环比较 实例1： 123456789101112131415161718#冒泡排序'''排序的总轮数=列表元素个数 - 1每轮元素互相比较的次数 = 列表元素个数 - 已经排好序的元素个数 - 1'''#data_list:待排序列表def bubble_sort(data_list): num = len(data_list) #列表元素个数 for i in range(0,num -1):#排序的总轮数 print("第&#123;&#125;轮：".format(i)) for j in range(0,num-i-1): if data_list[j] &gt; data_list[j+1]:#前后两个元素比较 data_list[j],data_list[j+1] = data_list[j+1],data_list[j] print(data_list)list = [28,32,14,12,53,42]bubble_sort(list)print('---------排序结果--------------')print(list) 结果： 12345678910111213141516171819202122第0轮：[28, 32, 14, 12, 53, 42][28, 14, 32, 12, 53, 42][28, 14, 12, 32, 53, 42][28, 14, 12, 32, 53, 42][28, 14, 12, 32, 42, 53]第1轮：[14, 28, 12, 32, 42, 53][14, 12, 28, 32, 42, 53][14, 12, 28, 32, 42, 53][14, 12, 28, 32, 42, 53]第2轮：[12, 14, 28, 32, 42, 53][12, 14, 28, 32, 42, 53][12, 14, 28, 32, 42, 53]第3轮：[12, 14, 28, 32, 42, 53][12, 14, 28, 32, 42, 53]第4轮：[12, 14, 28, 32, 42, 53]---------排序结果--------------[12, 14, 28, 32, 42, 53] 选择排序原理： 将待排序列表看成是已排序和未排序两部分 每次从未排序列表中找出最小值放到已排序列表末尾 PS:初始时，最小值假定为未排序的第一个位置的值实例2： 123456789101112131415161718#选择排序#data_list:待排序列表def select_sort(data_list): list_len = len(data_list) #待排序元素个数 for i in range(0,list_len-1):#控制排序比较总轮数 tmp_min_index = i for j in range(i+1,list_len): if data_list[tmp_min_index] &gt; data_list[j]: tmp_min_index = j if i != tmp_min_index: data_list[i],data_list[tmp_min_index] = data_list[tmp_min_index],data_list[i] print(data_list)list = [28,32,14,12,53,42]select_sort(list)print('---------排序结果--------------')print(list) 结果： 1234567[12, 32, 14, 28, 53, 42][12, 14, 32, 28, 53, 42][12, 14, 28, 32, 53, 42][12, 14, 28, 32, 53, 42][12, 14, 28, 32, 42, 53]---------排序结果--------------[12, 14, 28, 32, 42, 53] 快速排序原理： 一次排序按照一个基准值将待排序的列表分割成两部分，基准值左边是比基准值小的元素，基准值右边是比基准值大的元素 按照上一步的方法对基准值左右两部分数据分别进行快速排序 实例3： 12345678910111213141516171819202122232425262728293031323334#快速排序#data_list:待排序列表def quick_sort(data_list,start,end): #设置递归结束条件 if start &gt;= end: return low_index = start#低位游标 high_index = end #高位游标 basic_data = data_list[start] #初始基准值 #低位游标不能超过高位游标，防止到重合的点继续游标移动 while low_index &lt; high_index: #模拟高位游标从右向左指向的元素与基准值进行比较，比基准值大则高位游标一直向左移动 while low_index &lt; high_index and data_list[high_index] &gt;= basic_data: high_index -= 1 if low_index != high_index: #当高位游标指向的元素小于基准值，则移动该值到低位游标指向的位置 data_list[low_index] = data_list[high_index] low_index += 1 #低位游标向右移动一位 while low_index &lt; high_index and data_list[low_index]&lt;basic_data: low_index +=1 if low_index != high_index: data_list[high_index] = data_list[low_index] high_index -= 1 data_list[low_index] = basic_data #递归调用 quick_sort(data_list,start,low_index-1) #对基准值左边未排序队列排序 quick_sort(data_list,high_index+1,end) #对基准值右边未排序队列排序list = [28,32,14,12,53,42]quick_sort(list,0,len(list)-1)print('---------排序结果--------------')print(list) 结果： 12---------排序结果--------------[12, 14, 28, 32, 42, 53] 归并排序原理： 先递归分解序列，再排序合并序列 注意：图片第二行拆半拆分应该是：22 32 14 12 53 42 22 62的顺序，但是原理如图片所示 实例4： 123456789101112131415161718192021222324252627282930313233#归并排序#data_list:待排序列表def merge_sort(data_list): if len(data_list)&lt;=1: return data_list #根据列表长度确定拆分的中间位置 mid_index = len(data_list) // 2 # left_list = data_list[:mid_index] #使用切片实现对列表的切分 # right_list = data_list[mid_index:] left_list = merge_sort(data_list[:mid_index]) right_list = merge_sort(data_list[mid_index:]) return merge(left_list,right_list)def merge(left_list,right_list): l_index = 0 r_index = 0 merge_list = [] while l_index &lt; len(left_list) and r_index &lt; len(right_list): if left_list[l_index] &lt; right_list[r_index]: merge_list.append(left_list[l_index]) l_index += 1 else: merge_list.append(right_list[r_index]) r_index += 1 merge_list += left_list[l_index:] merge_list += right_list[r_index:] return merge_listlist = [28,32,14,12,53,42]new_list = merge_sort(list)print('---------排序结果--------------')print(new_list) 结果： 12---------排序结果--------------[12, 14, 28, 32, 42, 53]]]></content>
      <categories>
        <category>Python基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>冒泡排序</tag>
        <tag>选择排序</tag>
        <tag>快速排序</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python(八)]]></title>
    <url>%2F2018%2F07%2F08%2FPython-%E5%85%AB%2F</url>
    <content type="text"><![CDATA[re模块的使用链接：正则表达式 match(正则表达式，待匹配字符串(起始位置)） 用于正则匹配检查，如果待匹配字符串能够匹配正则表达式，则match方法返回匹配对象，否则返回None 采用从左往右逐项比较匹配 实例1： 123456##例如：新的邮箱手机号验证格式是否正确，用正则表达式对于格式验证import rers = re.match('chinahadoop','chinahadoop.cn')print(rs)print(rs.span()) 结果： 12&lt;_sre.SRE_Match object; span=(0, 11), match='chinahadoop'&gt;(0, 11) #匹配目标的位置 group()方法 用来返回字符串的匹配部分 实例2： 1234567##例如：新的邮箱手机号验证格式是否正确，用正则表达式对于格式验证import rers = re.match('chinahadoop','chinahadoop.cn')print(rs)print(rs.group()) 结果： 12&lt;_sre.SRE_Match object; span=(0, 11), match='chinahadoop'&gt;chinahadoop 字符匹配、数量表示、边界表示单字符匹配 Ps: ‘\d’ ‘\s’’\w’经常使用 实例3： 123456789101112131415161718import re##作用对文本进行处理的时候# . 是匹配除\n之外的任意单个字符rs = re.match('.','a') #第一个参数正则表达式print(rs.group())rs = re.match('.','1')print(rs.group())#单字符匹配rs = re.match('...','abc')print(rs.group())# rs = re.match('...','\n')# print(rs) ###最后一个会报错 结果： 1234a1abcNone 实例4： 12345678910111213import re# \s--任意空白字符，如空格，制表符'\t'、换行符'\n'rs = re.match('\s','\t')print(rs)rs = re.match('\s','\n')print(rs)rs = re.match('\s',' ')print(rs)#\Srs = re.match('\S\S\S','abc')print(rs) 结果： 1234&lt;_sre.SRE_Match object; span=(0, 1), match='\t'&gt;&lt;_sre.SRE_Match object; span=(0, 1), match='\n'&gt;&lt;_sre.SRE_Match object; span=(0, 1), match=' '&gt;&lt;_sre.SRE_Match object; span=(0, 3), match='abc'&gt; 实例5： 12345678910import rers = re.match('[Hh]','hello')print(rs)rs = re.match('[0123456789]','32')print(rs)#等价于上面的代码rs = re.match('[0-9],'32')print(rs) 结果： 123&lt;_sre.SRE_Match object; span=(0, 1), match='h'&gt;&lt;_sre.SRE_Match object; span=(0, 1), match='3'&gt;&lt;_sre.SRE_Match object; span=(0, 1), match='3'&gt; 多字符匹配（单字符+数量表示） 实例6： 123456# \d只匹配数字# *--任意次import rers = re.match('1\d*','1234')print(rs.group()) 结果： 11234 实例7： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#+至少出现一次rs = re.match("\d+","abc")print(rs)rs = re.match("\d+","1abc")print(rs)rs = re.match("\d+","123345abc")print(rs)print('=====分割线======')#?至多1次（0次或者1次）rs = re.match("\d?","abc")print(rs)rs = re.match("\d?","123abc")print(rs)print('=====分割线======')#&#123;m&#125;固定次数rs = re.match("\d&#123;3&#125;","123abc")print(rs)#&#123;m,&#125;rs = re.match("\d&#123;1,&#125;","123467abc")#等价于+至少一次print(rs)#&#123;m,n&#125;rs = re.match("\d&#123;0,1&#125;","abc") #等价于?至多一次print(rs)print('=====分割线======')#匹配11位的手机号#11位，第一位1，第二位3,5,7,8 第3位到第11为0到9的数字rs = re.match("1[3578]\d&#123;9&#125;","13623198765")print(rs)rs = re.match("1[3578]\d&#123;9&#125;","14623198765")#非法手机号print(rs)rs = re.match("1[3578]\d&#123;9&#125;","13623198765abc")#非法手机号print(rs)print('=====分割线======')#转义字符处理# str1 = "hello\\world"# print(str1)# str2 = "hello\\\\world"# print(str2)print('=====分割线======')str3 = r"hello\\world" #原生字符串 ##实际str3 = 'hello\\\\world'print(str3)# rs = re.match("\w&#123;5&#125;\\\\\\\\\w&#123;5&#125;",str3)# print(rs)rs = re.match(r"\w&#123;5&#125;\\\\\w&#123;5&#125;",str3)print(rs) 结果： 123456789101112131415161718None&lt;_sre.SRE_Match object; span=(0, 1), match='1'&gt;&lt;_sre.SRE_Match object; span=(0, 6), match='123345'&gt;=====分割线======&lt;_sre.SRE_Match object; span=(0, 0), match=''&gt;&lt;_sre.SRE_Match object; span=(0, 1), match='1'&gt;=====分割线======&lt;_sre.SRE_Match object; span=(0, 3), match='123'&gt;&lt;_sre.SRE_Match object; span=(0, 6), match='123467'&gt;&lt;_sre.SRE_Match object; span=(0, 0), match=''&gt;=====分割线======&lt;_sre.SRE_Match object; span=(0, 11), match='13623198765'&gt;None&lt;_sre.SRE_Match object; span=(0, 11), match='13623198765'&gt;=====分割线===========分割线======hello\\world&lt;_sre.SRE_Match object; span=(0, 12), match='hello\\\\world'&gt; 边界表示字符串与单词边界 应用场景：是否要加边界，区别：比如用户注册的时候验证他输入的邮箱就要加边界，限制他写入的是合法的邮箱，再比如处理文本数据的时候提取邮箱信息，有可能文本里的数据就是非法的，只是为了提取出邮箱，就不用加边界。 实例8： 1234567891011121314151617181920212223242526#边界表示# $字符串结尾import rers = re.match('1[3578]\d&#123;9&#125;$','13623456767')print(rs.group())rs = re.match('1[3578]\d&#123;9&#125;$','13623456767abc')print(rs)#邮箱匹配rs = re.match('\w&#123;3,10&#125;@163\.com$','hello_124@163.com') # \ 是转义字符（将特殊的符号转化为普通的字符），\.就是一个普通的点print(rs)print('=====分割线=====')#单词边界，用来查找关键字# \b rs = re.match(r'.*\bpython\b','hi python hello')print(rs)# \B# 非单词边界，查找字符串中重点的某些字符rs = re.match(r'.*\Btho\B','hi python hello') #如果有边界字母的话，就会返回noneprint(rs) 结果： 123456713623456767None&lt;_sre.SRE_Match object; span=(0, 17), match='hello_124@163.com'&gt;=====分割线=====&lt;_sre.SRE_Match object; span=(0, 9), match='hi python'&gt;&lt;_sre.SRE_Match object; span=(0, 8), match='hi pytho'&gt; 匹配分组 实例9： 1234567891011121314151617181920212223242526272829#匹配分组#匹配0-100之间的数字import rers = re.match(r'[1-9]\d?$|100$|0$','100')print(rs)rs = re.match(r'[1-9]\d?$|100$|0$','85')print(rs)rs = re.match(r'[1-9]\d?$|100$|0$','0')print(rs)rs = re.match(r'[1-9]$\d?$|100$|0$','0')print(rs)print('=======分割线======')rs = re.match('\w&#123;3,10&#125;@(163|qq|outlook)\.com$','hello@163.com')print(rs)print('=======分割线======')#\NUMhtml_str = '&lt;head&gt;&lt;title&gt;python&lt;/title&gt;&lt;/head&gt;'rs = re.match(r'&lt;(.+)&gt;&lt;(.+)&gt;.+&lt;/\2&gt;&lt;/\1&gt;',html_str)print(rs)print('=======分割线======')#(?P&lt;name&gt;)和(?P=name)分组起别名 #成对出现的标签，适合用分组起别名方法html_str = '&lt;head&gt;&lt;title&gt;python&lt;/title&gt;&lt;/head&gt;'rs = re.match(r'&lt;(?P&lt;g1&gt;.+)&gt;&lt;(?P&lt;g2&gt;.+)&gt;.+&lt;/(?P=g2)&gt;&lt;/(?P=g1)&gt;',html_str)print(rs) 结果： 12345678910&lt;_sre.SRE_Match object; span=(0, 3), match='100'&gt;&lt;_sre.SRE_Match object; span=(0, 2), match='85'&gt;&lt;_sre.SRE_Match object; span=(0, 1), match='0'&gt;&lt;_sre.SRE_Match object; span=(0, 1), match='0'&gt;=======分割线======&lt;_sre.SRE_Match object; span=(0, 13), match='hello@163.com'&gt;=======分割线======&lt;_sre.SRE_Match object; span=(0, 34), match='&lt;head&gt;&lt;title&gt;python&lt;/title&gt;&lt;/head&gt;'&gt;=======分割线======&lt;_sre.SRE_Match object; span=(0, 34), match='&lt;head&gt;&lt;title&gt;python&lt;/title&gt;&lt;/head&gt;'&gt; 正则表达式的高级用法search 从左到右在字符串的任意位置搜索第一次出现匹配给定正则表达式的字符 实例10： 1234import re# searchrs = re.search('car','haha car carbal abcar carbal')print(rs) 结果： 1&lt;_sre.SRE_Match object; span=(5, 8), match='car'&gt; findall 在字符串中查找所有匹配成功的组，返回匹配成功的结果列表 实例11： 123456789#findallrs = re.findall('car','haha car carbal abcar carbal')print(rs)print('=====分割线======')mail_str = 'zhangsan:helloworld@163.com,li:123456@qq.cn'list = re.findall(r'\w&#123;3,20&#125;@(163|qq)\.(com|cn)',mail_str)print(list)print('=====分割线======') 结果： 123['car', 'car', 'car', 'car']=====分割线======[('163', 'com'), ('qq', 'cn')] finditer 在字符串中查找所有正则表达式匹配成功的字符串，返回iterator迭代器 实例12： 1234#finditeritor = re.finditer(r'\w&#123;3,20&#125;@(163|qq)\.(com|cn)',mail_str)for it in itor: print(it.group()) 结果： 12helloworld@163.com123456@qq.cn sub 将匹配到的数据使用新的数据替换 实例13： 1234567891011121314# substr_list = 'java python c cpp java'rs = re.sub(r'java','python',str_list)print(rs)print('=====分割线======')str_test = "apple=5,banana=3,orange=2"def update_price(result): price = result.group() new_price = int(price) + 1 new_price = str(new_price) return new_pricers = re.sub(r"\d+",update_price,str_test)print(rs) 结果： 123python python c cpp python=====分割线======apple=6,banana=4,orange=3 split 根据指定的分隔符切割字符串，返回切割之后的列表 实例14： 12345#splitprice_list = str_test.split(',')for price in price_list: print(price) 结果： 123apple=5banana=3orange=2 贪婪与非贪婪模式贪婪模式 正则表达式引擎默认是贪婪模式，尽可能多的匹配字符 实例15： 1234567891011121314151617import re#贪婪模式rs = re.findall(r'hello\d*','hello12345')print(rs)rs = re.findall(r'hello\d+','hello12345') #至少出现一次print(rs)rs = re.findall(r'hello\d?','hello12345') #至多出现一次print(rs) rs = re.findall(r'hello\d&#123;2,&#125;','hello12345') #至少2次以上print(rs) rs = re.findall(r'hello\d&#123;1,3&#125;','hello12345') #1-3次print(rs) 结果： 12345['hello12345']['hello12345']['hello1']['hello12345']['hello123'] 非贪婪模式 与贪婪模式相反，尽可能少的匹配字符 在表示数量的’*’,’?’,’+’,’{m,n}’符号后面加上？，使贪婪变成非贪婪 实例16： 12345678910111213141516import re#非贪婪模式rs = re.findall(r'hello\d*?','hello12345')print(rs)rs = re.findall(r'hello\d+?','hello12345') #至少出现一次print(rs)rs = re.findall(r'hello\d??','hello12345') #至多出现一次print(rs) rs = re.findall(r'hello\d&#123;2,&#125;?','hello12345') #至少2次以上print(rs) rs = re.findall(r'hello\d&#123;1,3&#125;?','hello12345') #1-3次print(rs) 结果： 12345['hello']['hello1']['hello']['hello12']['hello1']]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>正则化表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python(七)]]></title>
    <url>%2F2018%2F07%2F08%2FPython-%E4%B8%83%2F</url>
    <content type="text"><![CDATA[类属性（可以理解为类中共享的全局变量）实例属性 所属于具体的实例对象，不同实例对象之间的实例属性互不影响 类属性 所属于类对象，多个实例对象之间共享同一个类属性 获取类属性方法：类名.类属性 通过实例对象不能够修改类属性 实例1： 1234567891011121314151617class Person: #类属性 sum_num = 0 def __init__(self,name): #赋值给实例属性 self.name = name #修改类属性值，每创建一个实例对象，类属性值+1 Person.sum_num += 1 p1 = Person('zhangsan')#通过实例对象访问类属性，通过类名访问类属性print(p1.sum_num,Person.sum_num)p2 = Person('lisi')print(p1.sum_num,p2.sum_num,Person.sum_num)##为什么没有构造实例对象的实例属性sum_num，还可以获取值？如果没有实例属性就会去类属性。 结果： 121 12 2 2 实例2： 123456789101112131415161718class Person: #类属性 sum_num = 0 def __init__(self,name): #赋值给实例属性 self.name = name #修改类属性值，每创建一个实例对象，类属性值+1 #Person.sum_num += 1 p1 = Person('zhangsan')#通过实例对象访问类属性，通过类名访问类属性#print(p1.sum_num,Person.sum_num)p2 = Person('lisi')##通过实例对象p1，来修改类属性的值p1.sum_num = 100print(p1.sum_num,p2.sum_num,Person.sum_num) 结果： 123100 0 0#由结果可知，通过实例对象不能修改类属性的值，如果修改的属性在实例中不存在，则动态添加实例属性 实例3： 12345678910111213class Person: #类属性 sum_num = 0 def __init__(self,new_name,new_num): #赋值给实例属性 self.name = new_name #定义一个与类属性同名的实例属性 self.sum_num = new_num #修改类属性值，每创建一个实例对象，类属性值加1 Person.sum_num += 1 p1 = Person('zhangsan',10)print(p1.sum_num,Person.sum_num) 结果： 12310 1#由结果可以看出，同时调用同名属性的时候，优先调用对象属性，不是类属性 类方法、静态方法类方法—操作类属性 所属于类对象，使用@classmethod修饰的方法 定义类方法的第一个参数通常以”cls”参数作为类对象被传入 调用方式：类名.类方法 或者 实例对象.类方法（不推荐） 实例3： 1234567891011121314151617181920212223class Person: #类属性 sum_num = 0 def __init__(self,new_name): #赋值给实例属性 self.name = new_name #类方法 @classmethod def add_sum_num(cls): #cls表示类对象 cls.sum_num += 1 print(cls.sum_num) #类方法调用#方法1 ：类名.类方法Person.add_sum_num()print('============分割线============')#：方法2：实例对象.类方法(不推荐这样调用类方法)p = Person('zhangsan')p.add_sum_num()#类方法(cls)和实例方法(self),类方法--类属性，实例方法--实例属性（很重要！！！） 结果： 1231============分割线============2 静态方法—-和类和对象没有太大关系 使用@staticmethod修饰的方法，不需要默认传递任何参数 调用方式：类名.静态方法 或者实例对象.静态方法 实例4： 123456789101112131415161718192021222324252627class Person: #类属性 sum_num = 0 def __init__(self,new_name): #赋值给实例属性 self.name = new_name #类方法 @classmethod def add_sum_num(cls): #cls表示类对象 cls.sum_num += 1 print(cls.sum_num) #静态方法，静态方法里面不用传入参数的 @staticmethod def static_test(): print('----静态方法----') Person.sum_num += 1 print(Person.sum_num) #调用静态方法(尽量少使用静态方法，如果要使用的话，可以在打印提示性的信息时候使用)Person.static_test()print('------------')p = Person('zhangsan')p.static_test()#总结：在类方法和静态方法中不能直接调用实例属性 结果： 12345----静态方法----1----------------静态方法----2 单例类new(cls) 超类object类内置的方法，用户创建对象，返回创建对象的引用 必须要提供cls参数，代表类对象 必须要有返回值，返回创建对象的引用 实例5： 12345678910111213141516171819202122232425"""#过程：解释器先用new方法来创建object对象，然后返回一个引用来给init构造方法，self就相当于返回对象的一个引用，接收到这个对象后，对对象进行初始化，打印构造方法后，返回对象的引用给变量db，变量db就指向内存中创建的这个对象。# cls--&gt;类对象 self--&gt;是传入的对象本身"""class DataBaseObj(object): #object是可以省略的，缺省object #init方法是无返回值 def __init__(self,new_name): #对象的初始化 print('-----init构造方法------') self.name = new_name print(self.name) def __new__(cls,name): #object类是所有类的基类，object这个类的new方法是创建对象 print('cls_id:',id(cls)) return object.__new__(cls) print(id(DataBaseObj)) ##打印的类对象的iddb = DataBaseObj('mysql')print('----分割线-----')print(db) 结果： 1234561706654249752cls_id: 1706654249752-----init构造方法------mysql----分割线-----&lt;__main__.DataBaseObj object at 0x0000018D5ED1FE10&gt; 单例类 在整个程序系统中确保某一个类只有一个实例对象 实例6： 1234567891011121314#单例类class SingleInstance: __instance = None def __init__(self): print("-----init-----") def __new__(cls): if cls.__instance == None: cls.__instance = object.__new__(cls) return cls.__instances1 = SingleInstance()print(id(s1))s2 = SingleInstance()print(id(s2)) 结果： 1234-------init-------1706683752288-------init-------1706683752288 异常处理链接：异常处理 捕获异常1234try: 逻辑代码块expect ExceptionType as err： 异常处理方法 实例7： 1234567try: open("test.txt", "r")except FileNotFoundError as err: print('捕获到了异常！文件不存在',err)print('哈哈哈哈') 结果: 12捕获到了异常！文件不存在 [Errno 2] No such file or directory: 'test.txt'哈哈哈哈 捕获多个异常1234try: 逻辑代码块except (ExceptionTypl1, ExceptionType2, ···) as err: 异常处理方法 实例8： 12345678try: print(num) print("==============") open("test.txt", "r")except (NameError,FileNotFoundError) as err: #用元组将所有异常括起来 print("捕获到了异常!",err)print("哈哈哈哈哈") 结果： 12捕获到了异常! name 'num' is not defined哈哈哈哈哈 捕获所有可能发生的异常123456try: 逻辑代码块except (ExceptionType1, ExceptionType2, ···) as err: 异常处理方法except ExceptionType as err： 异常处理方法 实例9： 12345678try: open("test.txt", "r")except NameError as err1: print("捕获到了异常!",err1)except Exception as err2: print("捕获所有可能的异常",err2)print("哈哈哈哈哈") 结果： 12捕获所有可能的异常 [Errno 2] No such file or directory: 'test.txt'哈哈哈哈哈 finally12345678try: 逻辑代码块exception(ExceptionType1, ExceptionType2, ···) as err: 异常处理方法except ExceptionType as err： 异常处理方法finally: 无论是否有异常产生，都会执行这里的代码块 实例10： 1234567891011f = Nonetry: f = open("test.txt","r") print("打印文件内容")except FileNotFoundError as error: print("捕获到了异常",error)finally: print("关闭文件") if f != None: print("正在关闭文件") f.close() 结果： 12捕获到了异常 [Errno 2] No such file or directory: 'test.txt'关闭文件 函数嵌套异常传递实例11： 12345678910111213141516def test1(): #通过打印的方式也可以查询问的所在处 print("------test1-1--------") print(num) #打印一个不存在的变量 print("------test1-2--------")def test2(): try: print("------test2-1--------") test1() print("------test2-2--------") except Exception as error: print("捕获到异常",error) print("------test2-3--------")test2() 结果： 123456789------test2-1--------------test1-1--------捕获到异常 name 'num' is not defined------test2-3--------##总结：异常处理的意义是防止某个业务产生异常而影响到整个程序中的其他业务。##当Python脚本发生异常时我们需要捕获处理它，否则程序会终止执行。 包和模块（包可以类比成文件夹）链接：模块和包 模块的名字： .py文件的名字下面是关于pycharm，能够引用包的设置步骤：若设置成功，则文件夹中间是实心，而非空心。 下图是包的形式，以.py的文件名字，包分别是bussiness和tool: 包下可以包含子包不同包下可以有相同的模块名称，使用‘包名.模块名’的方式区分实例12： 12345import bussiness.model1,tool.model1#import tool.model1bussiness.model1.project_info()tool.model1.tool_info() 引入模块的方式 引入单个模块：import module_name 引入多个模块：import module_name1,module_name2,··· 引入模块中的指定函数：from module_name import func1,func2,··· 实例13： 12345from bussiness import * #批量导入model3.test1()model3.test2()model3.test3()model1.project_info() 包中必须包含一个默认的init文件 用于标识一个包，而不是普通的文件夹 会在包或者该包下的模块被引入时自动调用 常用于设置包和模块的一些初始化操作 实例14： 12345#init可以对包进行初始化的设置print("init文件被自动调用")#__all__方法，这里指只有model3才能被其他的引用__all__ = ["model3"]]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>类属性</tag>
        <tag>类方法</tag>
        <tag>单例类</tag>
        <tag>异常处理</tag>
        <tag>包和模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python(六)]]></title>
    <url>%2F2018%2F07%2F08%2FPython-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[类的构造方法链接：类 调用时间：在对象被实例化时被程序自动调用 作用：用于对象创建时初始化 书写格式：init前后分别是两个下划线 程序不显示定义init方法，则程序默认调用一个无参init方法 对象创建过程 实例1: 1234567891011121314151617181920212223242526272829303132class Dog: def __init__(self): print("我是构造方法，在创建对象时自动调用")# self.gender = gender# self.variety = variety# self.name = name# self.__age = age # 获取对象属性，并打印出来 def get_pro(self): print("gender:&#123;&#125;,variety:&#123;&#125;,name:&#123;&#125;,age:&#123;&#125;".format(self.gender,self.variety,self.name,self.__age)) #设置对象内部属性 def set_pro(self,**kwargs): if "gender" in kwargs: self.gender = kwargs["gender"] elif "age" in kwargs: if kwargs["age"] &lt; 0 or kwargs["age"]&gt;20: print("非法年龄") else: self.__age = kwargs["age"] def eat(self): print("正在吃骨头...") def drink(self): print("正在喝水....") wangcai = Dog()wangcai.eat()wangcai.drink()# wangcai就是就是类所创建的实例对象 结果： 12345我是构造方法，在创建对象时自动调用正在吃骨头...正在喝水....#从结果可以看出，在创建对象的时候，init的方法会自动调用 init构造方法 设置对象属性 创建对象过程 实例2： 1234567891011121314class Dog:#通过init的构建方法来设置对象属性 def __init__(self,gender,variety,name,age): #print("我是构造方法，在创建对象时自动调用") self.gender = gender self.variety = variety self.name = name self.age = age wangcai = Dog('man','golden','wangcai','20')print(wangcai.gender)print(wangcai.variety)print(wangcai.name)print(wangcai.age) 结果： 1234mangoldenwangcai20 类的访问权限修改对象属性的方法 方法1：对象变量名.属性 = 新值 方法1的问题： 可能修改的属性值不合法 在类的外部可以随意修改类的内部属性 方法2：对象变量名.内部修改属性方法 实例3： 123456789101112131415class Dog: def __init__(self,gender,variety,name,age): #print("我是构造方法，在创建对象时自动调用") self.gender = gender self.variety = variety self.name = name self.age = age wangcai = Dog('man','golden','wangcai','20')#修改对象属性，方法1直接修改wangcai.age = 100print(wangcai.age) 结果： 1100 实例4： 12345678910111213141516171819202122232425class Dog: def __init__(self,gender,variety,name,age): #print("我是构造方法，在创建对象时自动调用") self.gender = gender self.variety = variety self.name = name self.age = age def get_pro(self): print("gender:&#123;&#125;,variety:&#123;&#125;,name:&#123;&#125;,age:&#123;&#125;".format(self.gender,self.variety,self.name,self.age)) #设置对象内部属性 def set_pro(self,**kwargs): if "gender" in kwargs: self.gender = kwargs["gender"] elif "age" in kwargs: if kwargs["age"] &lt; 0 or kwargs["age"]&gt;20: print("非法年龄") else: self.age = kwargs["age"]wangcai = Dog("male","golden","wangcai",1)#方法2：通过内部方法修改属性wangcai.set_pro(age=10)wangcai.get_pro()##这种方法还是可以直接从外部直接修改属性，不够安全，所以引入私有属性概念 结果： 1gender:male,variety:golden,name:wangcai,age:10 私有属性 定义：__私有变量名 只能在类内部使用，类外部不能访问，否则报错 实例5： 123456789101112131415161718192021222324##将age变为私有属性class Dog: def __init__(self,gender,variety,name,age): #print("我是构造方法，在创建对象时自动调用") self.gender = gender self.variety = variety self.name = name self.__age = age def get_pro(self): print("gender:&#123;&#125;,variety:&#123;&#125;,name:&#123;&#125;,age:&#123;&#125;".format(self.gender,self.variety,self.name,self.__age)) #设置对象内部属性 def set_pro(self,**kwargs): if "gender" in kwargs: self.gender = kwargs["gender"] elif "age" in kwargs: if kwargs["age"] &lt; 0 or kwargs["age"]&gt;20: print("非法年龄") else: self.__age = kwargs["age"]wangcai = Dog('man','golden','wangcai',20)wangcai.get_pro()###如果def_pro和def set_pro中的age不加双下划线，则会报错出不存在age这个属性 结果： 1gender:man,variety:golden,name:wangcai,age:20 私有方法 只有在类内部调用，在类的外部无法调用 定义私有方法在方法名前添加两个下划线 类内部调用私有方法要使用self.私有方法的方式调用 实例6： 1234567891011121314#私有方法的使用class Comrade: #私有方法 def __send_message(self): print("消息已经向上级汇报") def answer_secret(self,secret): if secret == "芝麻开门": print("接头成功!") self.__send_message()#调用私有方法 else: print("接头失败！")comrade = Comrade()comrade.answer_secret("芝麻开门") 结果： 12接头成功!消息已经向上级汇报 继承在程序中，继承描述的是类中类型与子类型之间的所属关系，例如猫和狗都属于动物 单继承 子类继承一个父类，在定义子类时，小括号()中写父类的类名 父类的非私有属性、方法，会被子类继承 子类中方法的查找方式：先查找子类中对应的方法，如果找不到，再到父类中查找 子类可以继承父类的属性和方法，也可以继承父类的非私有属性和方法，依次类推 在子类中调用父类的方法：ClassName.methodname(self) 实例7： 12345678910111213141516171819202122232425262728293031323334353637class Animal: def __init__ (self): print("---animal构造方法----") def __private_method(self): print('私有方法') def eat(self): print('-----吃-----') def drink(self): print('-----喝-----') def run(self): print('-----跑-----')class Dog(Animal): def __init__(self): print('dog构造方法') def hand(self): ##子类在类里面调用父类的方法 Animal.run(self) print('----握手-----')wangcai =Dog()#调用从父类继承的方法wangcai.eat()wangcai.drink()wangcai.run()#调用自身的方法wangcai.hand()#调用父类的私有方法，会被报错，不能继承父类的私有方法# wangcai.__private_method#如果在子类中没有定义init构造方法，则自动调用父类的init构造方法，如果在子类中定义了init构造方法，则不会调用父类的构造方法duoduo = Dog()duoduo.run() 结果： 12345678dog构造方法-----吃----------喝----------跑----------跑---------握手-----dog构造方法-----跑----- 重写父类方法 子类对父类允许访问的方法的实现过程进行重新编写 在子类中定义与父类同名的方法 优点：子类可以根据需要，定义合适的方法实现逻辑 实例8： 123456789101112131415161718192021class Animal: def __init__ (self): print("---animal构造方法----") def __private_method(self): print('私有方法') def eat(self): print('-----吃-----') def drink(self): print('-----喝-----') def run(self): print('-----跑-----')class Dog(Animal): #父类方法重写 #只要够名称覆盖掉父类的方法就可以实现重写 def run(self): print('摇着尾巴跑') def hand(self): print('----握手-----')wangcai =Dog()wangcai.run() 结果： 12---animal构造方法----摇着尾巴跑 多继承 object 类是所有类的基类，在定义类的时候不需要显示的在括号中表明继承自object类 多继承：一个子类可以继承多个父类 多继承定义方式：在类名后的括号中添加需要继承的多个类名 多继承中，如果多个类中有同名的方法，子类调用查找方法的顺序是按照小括号内继承父类从左到右的顺序查找，第一个匹配方法名的父类方法将会被调用 实例9： 123456789101112131415161718192021222324#多继承中方法的名称尽量不一样，要不然会出现不必要的错误和困扰，比如下面的data_handleclass AI: #人脸识别 def face_recongnition(self): print("人脸识别") def data_handle(self): print("AI数据处理")class BigData: def data_analysis(self): print("数据分析") def data_handle(self): print("BigData数据处理")class Python(BigData,AI): def operation(self): print("自动化运维") py = Python()py.face_recongnition()py.data_analysis()py.operation()py.data_handle()print(Python.__mro__) #查看调用方法的搜索顺序 结果： 12345人脸识别数据分析自动化运维BigData数据处理(&lt;class '__main__.Python'&gt;, &lt;class '__main__.BigData'&gt;, &lt;class '__main__.AI'&gt;, &lt;class 'object'&gt;) 多态一个抽象类有多个子类，不同的类表现出多种形态 实例10： 1234567891011121314151617181920#子类的的方法是会覆盖掉父类的方法，只有存在继承，才能存在多态class Animal: def eat(self): print("Animal正在吃饭")class Dog(Animal): def eat(self): print("Dog正在吃饭")class Cat(Animal): def eat(self): print("Cat正在吃饭")def show_eat(obj): obj.eat()wangcai = Dog()show_eat(wangcai)tom = Cat(show_eat(tom) 结果： 12Dog正在吃饭Cat正在吃饭]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>类的构造方法</tag>
        <tag>继承</tag>
        <tag>类的访问权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python(五)]]></title>
    <url>%2F2018%2F07%2F08%2FPython-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[日期和时间链接：日期与时间的教程 time模块 time()函数获取当前时间戳 localtime([seconds])格式化时间戳为本地时间，返回时间元组 链接：time模块 tm_isdst：是否为夏令默认为-1 实例1： 1234import time; # 引入time模块ticks = time.time()print ("当前时间戳为:", ticks) 结果： 123451523707408.4362438##时间间隔是以秒为单位的浮点小数。##每个时间戳都以自从1970年1月1日午夜（历元）经过了多长时间来表示。##时间戳单位最适于做日期运算。但是1970年之前的日期就无法以此表示了。太遥远的日期也不行，UNIX和Windows只支持到2038年。 实例2： 12import timeprint(time.localtime(time.time())) 结果： 1time.struct_time(tm_year=2018, tm_mon=4, tm_mday=14, tm_hour=21, tm_min=13, tm_sec=30, tm_wday=5, tm_yday=104, tm_isdst=0) 实例3： 12345#获取格式化时间import timelocaltime = time.asctime( time.localtime(time.time()) )print ("本地时间为 :", localtime) 结果： 1本地时间为 : Sat Apr 14 21:22:05 2018 time.strftime(format[,time_tuple])格式化日期函数 time.strptime(string, format)将日期时间字符串转换为时间元组 time.mktime(time_tuple)将时间元组转换成时间戳 实例4： 123456789# 格式化成2018-04-14 21:46:50形式print (time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))# 格式化成Sat Apr 14 21:46:50 2018形式print (time.strftime("%a %b %d %H:%M:%S %Y", time.localtime())) # 将格式字符串转换为时间戳a = "Sat Apr 14 21:46:50 2018"print (time.mktime(time.strptime(a,"%a %b %d %H:%M:%S %Y"))) 结果： 1232018-04-14 21:46:50Sat Apr 14 21:46:50 20181459171464.0 time.sleep(seconds)将程序睡眠等待几秒钟 实例5： 12345#sleep(秒)程序睡眠时间start_time = time.time()time.sleep(5)end_time = time.time()print(end_time - start_time) 结果： 15.0000221729278564 datetime模块链接：datatime模块 datetime.datetime.now()获取当前日期和时间 实例6： 1234#获取当前时间import datetimeprint(datetime.datetime.now()) 结果： 12018-04-14 22:08:00.916396 strftime(format)日期时间格式化 datetime.datetime.formtimestamp(timestamp)将时间戳转换为日期时间 datetime.datetime.fromtimestamp(timestamp)将时间戳转换为日期时间 实例7： 123#日期时间格式化import datetimeprint(datetime.datetime.now().strftime("%Y/%m/%d %H:%M:%S")) 结果： 12018/04/14 22:11:13 datetime.timedelta(时间间隔)返回一个时间间隔对象，通过时间间隔可以对时间进行加减法得到新的时间 实例8： 12345678910111213import timeimport datetimestart_time = datetime.datetime.now()time.sleep(2)end_time = datetime.datetime.now()print(start_time) #当前时间print(end_time) #结束时间print(end_time-start_time) #时间间隔print((end_time-start_time).seconds) print('==============')ts = time.time() #当前时间戳print(ts)print(datetime.datetime.fromtimestamp(ts)) 结果： 12345672018-04-15 01:22:34.7136392018-04-15 01:22:36.7142880:00:02.0006492==============1523722956.73032642018-04-15 01:22:36.730326 实例9： 1234567#计算昨天的日期import datetimetoday = datetime.datetime.today()print(today.strftime("%Y-%m-%d %H:%M:%S"))timedelta = datetime.timedelta(days=1)yesterday = today - timedeltaprint(yesterday.strftime("%Y-%m-%d %H:%M:%S")) 结果： 122018-04-15 01:23:362018-04-14 01:23:36 文件与文件夹操作链接：python文件I/O 链接：python 文件夹操作方法 open(文件路径，访问模式，encoding = 编码格式)方法打开一个已存在的文件，或者创建新的文件 123456789file object = open(file_name [, access_mode][, buffering])参数：ile_name：file_name变量是一个包含了你要访问的文件名称的字符串值。access_mode：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。buffering:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。 close()方法关闭已打开的文件 下表为access_mode不同参数打开文件的完全列表，取自菜鸟课程，点击上述链接可以获得。 实例10： 1234567891011import osimport shutil#文件不存在报错# f = open("test.txt","r")# f.close() #切结要关闭#文件不存在则创建#覆盖已存在的内容,encoding="utf-8"解决中文乱码f = open("test.txt","w",encoding="utf-8")f.write("你好")f.close() 打开文件常用的三种访问模式 r ：只读模式（默认） w ：只写模式 a : 追加模式 write（data）方法向文件中写入字符串 read()方法读取文件全部内容 实例11： 12345#read读文件f = open("test.txt","r",encoding="utf-8")print(f.read())f.close() 结果： 123你好#txt文件中的‘你好’ 实例12： 12f = open("test.txt","a",encoding="utf-8") #覆盖已存在的内容,encoding="utf-8"解决中文乱码f.write("\n大家好") 结果： 1234你好大家好##a是指追加，在原有的你好的基础上追加大家好的内容 readlines()方法读取文件全部内容，放回一个列表，每行数据是列表中的一个元素 实例13： 1234567891011#readlines按行全部读取文件数据，返回一个文件数据列表，每一行是列表的一个元素f = open("test.txt","r",encoding="utf-8")data = f.readlines()print(data)print("-----------")i = 1for line in data: print("第&#123;&#125;行：&#123;&#125;".format(i,line),end="") i += 1f.close() 结果： 1234['你好\n', '大家好']-----------第1行：你好第2行：大家好 readline()方法按行读取文件数据 实例14： 12345678910#readlinef = open("test.txt","r",encoding="utf-8")line1 = f.readline()print(line1,end="")line2 = f.readline()print(line2,end="")#line3 = f.readline()#print(line3,end="")f.close() 结果： 12你好大家好 writelines(字符串序列)将一个字符串序列（如字符串列表等）的元素写入到文件 实例15： 12345#writelines向文件写入一个字符串序列f = open("test.txt","w",encoding="utf-8")f.writelines(["张三\n","李四\n","王五\n"])f.close() 结果： 12345张三李四王五##以上为文件中内容 os.rename(oldname,newname)文件重命名 os.remove(filepath)删除文件 安全的打开关闭文件的方式（自动调用close方法）： 实例16： 123# 用with open as f的语句with open("d://test.txt","w") as f: f.write('hello python') 实例16： 123456789import os # 重命名文件test1.txt到test2.txt。os.rename( "test.txt", "test2.txt" )import os # 删除一个已经存在的文件test2.txtos.remove("test2.txt") os.mkdir(path) 创建文件夹 os.getcwd()获取程序运行的当前目录 os.listdir(path)删除获取指定目录下的文件列表 os.rmdir(path)删除空文件夹 shutil.rmtree(path)删除非空文件夹 os.chdir(path)切换目录 123456789101112131415161718import osimport shutilos.mkdir("d://testdir123")print(os.getcwd())print(os.listdir("d://"))os.rmdir("d://testdir123")shutil.rmtree("d://testdir123")path = os.getcwd() #程序运行的当前路径print(path)os.chdir("../") #切换到上一级目录path = os.getcwd()print(path)os.chdir("d://") #切换到上一级目录path = os.getcwd()print(path) JSON格式文件操作 引入json模块：import json dumps(python_data):将Python数据转换为JSON编码的字符串 loads(json_data): 将json编码的字符串转换为python的数据结构 实例17： 1234567891011import json#dumps和loadsjson_dict = &#123;"name":"zhangsan","age":20,"language":["python","java"],"study":&#123;"AI":"python","bigdata":"hadoop"&#125;,"if_vip":True&#125;'''json_str = json.dumps(json_dict)print(json_str)print(type(json_str))python_data = json.loads(json_str)print(python_data)print(type(python_data)) 结果： 1234&#123;"name": "zhangsan", "age": 20, "language": ["python", "java"], "study": &#123;"AI": "python", "bigdata": "hadoop"&#125;, "if_vip": true&#125;&lt;class 'str'&gt;&#123;'name': 'zhangsan', 'age': 20, 'language': ['python', 'java'], 'study': &#123;'AI': 'python', 'bigdata': 'hadoop'&#125;, 'if_vip': True&#125;&lt;class 'dict'&gt; dump(python_data,file):将python数据转换为JSON编码的字符串，并写入文件 load(json_file):从JSON数据文件中读取数据，并将json编码的字符串转换为python的数据结构 python数据类型与JSON类型对比 实例18： 123456789#dump和loadwith open("d://user_info.json","w") as f: #文件操作完自动调用close方法关闭 json.dump(json_dict,f)with open("d://user_info.json","r") as f: user_info_data = json.load(f) print(user_info_data) print(type(user_info_data)) 结果： 12&#123;'name': 'zhangsan', 'age': 20, 'language': ['python', 'java'], 'study': &#123;'AI': 'python', 'bigdata': 'hadoop'&#125;, 'if_vip': True&#125;&lt;class 'dict'&gt; CSV格式文件操作链接：csv操作 csv格式文件默认以逗号分隔 引入csv模块：import csv writerow([row_data])一次写入一行数据 writerows([[row_data],[row_data],···])一次写入多行数据 实例19： 1234567891011##csv文件操作#向csv文件写数据datas = [["nam'''e","age"],["张三",20],["lisi",30]] #第一个列表是表示csv文件的标题with open("d://user_info_csv.csv","w",newline="",encoding="utf-8") as f: writer = csv.writer(f) for row in datas:# #一次写入一行 writer.writerow(row)# #一次写入多行 writer.writerows(datas) reader(file_object)根据打开的文件对象返回一个可迭代reader对象 可以使用next(reader)遍历reader对象，获取每一行数据 实例19： 1234567891011#从csv文件读数据with open("d://user_info_csv.csv","r",newline="",encoding="utf-8") as f: reader = csv.reader(f) #reader可迭代对象 header = next(reader) #读一行数据 print(header) print("------------") for row in reader: print(row) print(row[0]) print(row[1]) 结果： 1234567891011121314151617181920212223242526272829303132333435["nam'''e", 'age']------------["nam'''e", 'age']nam'''eage['张三', '20']张三20['lisi', '30']lisi30['张三', '20']张三20["nam'''e", 'age']nam'''eage['张三', '20']张三20['lisi', '30']lisi30['lisi', '30']lisi30["nam'''e", 'age']nam'''eage['张三', '20']张三20['lisi', '30']lisi30 DictWrite和DictReader对象处理Python字典类型的数据 实例20： 12345678910111213header = ["name","age"]rows = [&#123;"name":"zhangsan","age":20&#125;,&#123;"name":"lisi","age":30&#125;,&#123;"name":"wangwu","age":18&#125;]with open("d://user_info_csv_dict.csv","w",newline="",encoding="utf-8") as f: writer = csv.DictWriter(f,header) writer.writeheader() writer.writerows(rows)with open("d://user_info_csv_dict.csv","r",newline="",encoding="utf-8") as f: reader = csv.DictReader(f) for row in reader: print(row) print("name:&#123;&#125;,age:&#123;&#125;".format(row["name"],row["age"])) 结果： 123456OrderedDict([('name', 'zhangsan'), ('age', '20')])name:zhangsan,age:20OrderedDict([('name', 'lisi'), ('age', '30')])name:lisi,age:30OrderedDict([('name', 'wangwu'), ('age', '18')])name:wangwu,age:18 面向对象编程链接：面对对象编程 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量, 用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 实例变量：定义在方法中的变量，只作用于当前实例的类。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 方法：类中定义的函数。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 类与对象的关系：类相当于创建对象的模板，根据类可以创建多个对象 类的构成：类的名称、类的属性、类的方法 类的定义 实例21： 1234567891011####class 类名： def 方法名(self,[,参数列表])#####定义类class Dog: def eat(self): print("小狗正在啃骨头...") def drink(self): print("小狗正在喝水...") 类的命名规则按照“大驼峰”，首字母大写 定义的方法默认要传入一个self参数，表示自己，self参数必须是第一个参数 创建对象：对象变量名 = 类名() 实例22： 1234567891011121314151617181920#定义类class Dog: name = 'petter' def eat(self): print("小狗正在啃骨头...") def drink(self): print("小狗正在喝水...")#创建对象wang_cai = Dog()print(id(wang_cai))wang_cai.eat()wang_cai.drink()a_fu = Dog()# id([object])返回对象的内存地址print(id(a_fu))a_fu.eat()a_fu.drink()print(a_fu.name) 结果： 12345671379489803568小狗正在啃骨头...小狗正在喝水...1379489740056小狗正在啃骨头...小狗正在喝水...petter]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>日期与时间</tag>
        <tag>文件与文件夹操作</tag>
        <tag>面对对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python(四)]]></title>
    <url>%2F2018%2F07%2F08%2FPython-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[函数 函数相关的链接：函数 定义：函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。可以理解为对实现某一功能的封装。 函数的语法格式：123def 函数名称（参数）： 函数体代码 return 返回值 函数定义以及函数调用（函数名（参数））实例1： 1234567#函数的定义def print_user_info(): print("name:zhangsan") print("age:20") print("gender:male")print_user_info() 结果： 123name:zhangsanage:20gender:male 函数参数 形参：定义函数时设置的参数 调用函数时传入的参数 实例2： 123456789101112#带参函数注意，1.调用函数时传入的参数个数与函数定义参数个数相同。2.参数顺序要相同#有参无返回值函数##形参：name，age，gender##实参：悟空，20，maledef print_user_info2(name,age,gender): print("name:%s"%name) print("age:%d"%age) print("gender:%s"%gender)print_user_info2("悟空",20,"male")print_user_info2("八戒",18,"male")print_user_info() 函数类型 无参无返回值函数 无参有返回值函数 有参无返回值函数 有参有返回值函数 实例3： 1234567#有返回值函数def x_y_sum_return(x,y): res = x + y return resz = x_y_sum_return(2,3)print(z) 结果： 15 变量局部变量 函数内部定义函数 不同函数内的局部变量可以定义相同的名字，互不影响 作用范围：函数体内有效，其他函数不能直接使用 链接：局部和全局变量 此链接推荐阅读，讲的很详细，下面会摘取一些例子 实例4： 1234567891011#局部变量def set_name(): name = "zhangsan" return namedef get_name(name): #name = "lisi" print(name)nm = set_name()get_name(nm) 结果： 123lisi#从结果可以看出，打印的并非zhangsan，而是lisi，因为调用的是get_name函数里面的局部变量name 全局变量 函数外部定义的变量 作用范围：可以再不同函数中使用 在函数内使用global关键字实现修改全局变量的值 全局变量命名建议以g_开头，如g_game 实例5： 12345678910111213#全局变量#可以在不同的函数中使用'''name = "zhangsan"def get_name(): print(name)def get_name2(): print(name)get_name()get_name2()print(name) 结果： 12345zhangsanzhangsanzhangsan#打印name，所有函数全部调用了全部变量的name 实例6： 12345678910111213141516171819202122#修改全局变量的值age = 20def change_age(): age = 25 #重新定义了一个局部变量age #global age #age = 25 print("函数体内age=%d"%age)change_age()print("函数体外age=%d"%age)print('================')age = 20def change_age(): #age = 25 #重新定义了一个局部变量age global age age = 25 print("函数体内age=%d"%age)change_age()print("函数体外age=%d"%age) 结果： 12345678函数体内age=25函数体外age=20=======================函数体内age=25函数体外age=25##可以看出，如果不对局部变量用关键词global进行申明，函数体外打印的值还是全局变量age = 20，如果对进行global申明，那函数体内的局部变量就会代替体外的全局变量成为新的全局变量，所以申明后的体外打印的age =25 实例7： 12345678910#全局变量定义的位置g_num1 = 100def print_global_num(): print("g_num1:%d"%g_num1) print("g_num2:%d"%g_num2) print("g_num3:%d"%g_num3)g_num2 = 200print_global_num()g_num3 = 300 结果： 123g_num1:100g_num2:200g_num3:300 实例8： 123456789101112#字典、列表作为全局变量，在函数内修改这种类型的全局变量中的元素g_num_list = [1,2,3]g_info_dict = &#123;"name":"zhangsan","age":20&#125;def update_info(): g_num_list.append(4) g_info_dict["gender"] = "male"update_info()print(g_num_list)print(g_info_dict) 结果： 12[1, 2, 3, 4]&#123;'name': 'zhangsan', 'age': 20, 'gender': 'male'&#125; 实例9： 123456num = 100def func(): num = 123 print(num)func() 结果： 123123##函数内部的变量名如果第一次出现，且出现在=前面，即被视为定义一个局部变量，不管全局域中有没有用到该变量名，函数中使用的将是局部变量 函数参数链接：函数参数 可在此链接查看函数的参数，参数分四种（必须参数，关键字参数，默认参数，不定长参数等） 缺省参数 函数定义带有初始值的形参 函数调用时，缺省参数可传，也可不穿 缺省参数一定要位于参数列表的最后 缺省参数数量没有限制 实例10： 1234567#缺省参数def x_y_sum(x,y=20): print("x=%d"%x) print("y=%d"%y) return x + yprint(x_y_sum(20)) 结果： 123x = 20y = 2040 实例11： 123def x_y_sum2(y=10,x): return x + yprint(x_y_sum2(10)) 结果： 123456 File "&lt;ipython-input-31-cc4701538993&gt;", line 1 def x_y_sum2(y=10,x): ^SyntaxError: non-default argument follows default argument###从上面报错得知，缺省参数一定要位于参数列表的的最后 命名参数 调用带有参数的函数时，通过指定参数名称传入参数的值 可以不按函数定义的参数顺序传入 实例12： 12345678910def x_y_sum(x=10,y=20): return x + y#注意：函数调用的时候命名参数的名称与函数定义时的形参名称相同，但是顺序可以不同rs1 = x_y_sum(y=30,x=15)rs2 = x_y_sum(x=15)rs3 = x_y_sum()print("rs1=%d"%rs1)print("rs2=%d"%rs2)print("rs3=%d"%rs3) 结果： 1234567rs1=45rs2=35rs3=30##结果可以看出 rs1是通过命名参数的的输入，得出的结果##rs2是y是缺省参数，x是命名参数，相加得到的结果##rrs3是相加的两个数都是缺省参数相加 不定长参数 函数可以接受不定个数的参数传入 def function([formal_args,]*args)函数调用时，传入的不定参数会被封装成元组 def function([formal_args,]**args)函数调用时，如果传入key = value的形式的不定长参数，会被封装成字典 实例13： 1234567891011#不定长参数#第一种def fuction([formal_args,]*args)def any_num_sum(x,y=10,*args): print("args=&#123;&#125;".format(args)) rs = x + y if len(args) &gt; 0: for arg in args: rs += arg return rsrs1 = any_num_sum(20,10,30,40,50,60) 结果： 1234args=(30, 40, 50, 60)210# x = 20 ， y = 10 然后再讲被封装成元组的不定长参数依次相加，得到结果210 实例14： 123456789101112#改变不定长参数的位置def any_num_sum2(x,*args,y=10): print("args=&#123;&#125;".format(args)) print("x=&#123;&#125;".format(x)) print("y=&#123;&#125;".format(y)) rs = x + y if len(args) &gt; 0: for arg in args: rs += arg return rs rs2 = any_num_sum2(20,30,40,50,60,y=100) 结果： 1234args=(30, 40, 50, 60)x=20y=100300 实例15： 123456789101112131415#第二种def fuction([formal_args,]**kvargs)#养老 医疗 公积金def social_insurance_comp(basic_money,**proportion): print(proportion) e_money = basic_money * proportion["e"] m_money = basic_money * proportion["m"] a_money = basic_money * proportion["a"] total_money = e_money + m_money + a_money return e_money,m_money,a_money,total_moneye,m,a,t = social_insurance_comp(8000,e=0.2,m=0.1,a=0.12)print("养老：&#123;&#125;,医疗：&#123;&#125;，公积金：&#123;&#125;，缴费总额：&#123;&#125;".format(e,m,a,t)) 结果： 12&#123;'e': 0.2, 'm': 0.1, 'a': 0.12&#125;养老：1600.0,医疗：800.0，公积金：960.0，缴费总额：3360.0 拆包 对于定义了不定长参数的函数，在函数调用时需要把已定义好的元组或者列表传入到函数中，需要使用拆包方法 实例16： 1234567891011121314#拆包#工资计算器def salary_comp(basic_money,*other_money,**proportion): print("缴费基数:&#123;&#125;".format(basic_money)) print("其他工资:&#123;&#125;".format(other_money)) print("比例:&#123;&#125;".format(proportion))other_money = (500,200,100,1000)proportion_dict = &#123;"e":0.2,"m":0.1,"a":0.12&#125;print('未使用拆包的：')salary_comp(8000,other_money,proportion_dict)#未使用拆包print('=========')salary_comp(8000,*other_money,**proportion_dict) 结果： 123456789未使用拆包的：缴费基数:8000其他工资:((500, 200, 100, 1000), &#123;'e': 0.2, 'm': 0.1, 'a': 0.12&#125;)比例:&#123;&#125;=========缴费基数:8000其他工资:(500, 200, 100, 1000)比例:&#123;'e': 0.2, 'm': 0.1, 'a': 0.12&#125;##如果不拆包的话，就会使other_money和proportion_dict被封装成元组变为实参，进入函数内执行。 递归函数和匿名函数递归函数 函数调用自身 注意：递归过程中要有用于结束递归的判断 实例17： 12345678910111213141516171819202122232425#递归函数，自身调用自身'''1! = 12! = 2 * 13! = 3 * 2 * 1...n! = n * (n-1)!'''#for循环实现def recursive_for(num): rs = num for i in range(1,num):# (1,4) = [1,2,3) rs *= i return rsrs = recursive_for(4)print(rs)##递归函数实现def recursive(num): if num &gt; 1: return num * recursive(num -1) #这里就是函数的递归，调用自身 else: return numprint(recursive(4)) 结果： 1224 24 匿名函数 用lambda关键字创建匿名函数 定义：lambda[参数列表]：表达式 匿名函数可以作为参数被传入其他函数 实例18： 123456#匿名函数sum = lambda x,y:x+yprint(sum(10,20))#等价函数def sum(x,y): return x + y 结果： 130 实例19： 123456789#1.匿名函数作为参数传入到自定义函数中def x_y_comp(x,y,func): rs = func(x,y) print(rs)x_y_comp(3,5,lambda x,y:x+y)print("----------------")x_y_comp(4,7,lambda x,y:x*y) 实例20： 链接：sort的用法 123456789#2.匿名函数作为python内置函数的参数使用user_infos = [&#123;"name":"zhangsan","age":20&#125;,&#123;"name":"lisi","age":30&#125;,&#123;"name":"wangwu","age":18&#125;]print(user_infos)user_infos.sort(key=lambda info:info["age"])print(user_infos)user_infos.sort(key=lambda info:info["age"],reverse=True)print(user_infos) 结果： 123[&#123;&apos;name&apos;: &apos;zhangsan&apos;, &apos;age&apos;: 20&#125;, &#123;&apos;name&apos;: &apos;lisi&apos;, &apos;age&apos;: 30&#125;, &#123;&apos;name&apos;: &apos;wangwu&apos;, &apos;age&apos;: 18&#125;][&#123;&apos;name&apos;: &apos;wangwu&apos;, &apos;age&apos;: 18&#125;, &#123;&apos;name&apos;: &apos;zhangsan&apos;, &apos;age&apos;: 20&#125;, &#123;&apos;name&apos;: &apos;lisi&apos;, &apos;age&apos;: 30&#125;][&#123;&apos;name&apos;: &apos;lisi&apos;, &apos;age&apos;: 30&#125;, &#123;&apos;name&apos;: &apos;zhangsan&apos;, &apos;age&apos;: 20&#125;, &#123;&apos;name&apos;: &apos;wangwu&apos;, &apos;age&apos;: 18&#125;]]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python(三)]]></title>
    <url>%2F2018%2F07%2F08%2FPython-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[元组（tuple）元组的相关链接：tuple 顺序存储相同/不同类型的元素 元组定义，使用将元素括起来，元素之间用“，”，隔开 实例1: 1db_info = ("192.168.10.1",3306,"root","root123") 特性：不可变，不支持添加、修改、删除元素操作 实例2: 1234#这里会报错，元素是不能修改的db_info[0] = 5del db_info[1]#不支持删除 结果： 123456789101112TypeError Traceback (most recent call last)&lt;ipython-input-2-006550c675f2&gt; in &lt;module&gt;()----&gt; 1 db_info[0] = 5TypeError: 'tuple' object does not support item assignment-----------------------------------------------------------------------TypeError Traceback (most recent call last)&lt;ipython-input-7-3bc97da19d51&gt; in &lt;module&gt;()----&gt; 1 del db_info[1]#不支持删除TypeError: 'tuple' object doesn't support item deletion 查询：通过下标查询元组指定位置的元素 实例3: 1234ip = db_info[0]port = db_info[1]print(ip)print(port) 结果： 12192.168.10.13306 空元组、只有一个元素的元组 实例4: 1234567#定义只有一个元素的元组one_tuple = ("zhangsan",)#空元组none_tuple = ()print(one_tuple)print(none_tuple) 结果： 12('zhangsan',)() 循环遍历元组 实例5: 123#循环遍历元组for item in db_info: print(item) 结果： 1234192.168.10.13306rootroot123 字典（dict）字典相关链接：dict 存储Key-Value键值对类型的数据 字典定义：{key1:value1 , key2:value2 , ···} 实例6: 12#字典user_info_dict = &#123;"name":"悟空","age":100,"gender":"male","job":"取经"&#125; 查询：根据Key查找Value 字典具有添加、修改、删除操作 实例7: 12345#对键值进行修改以及取值user_info_dict = &#123;"name":"悟空","age":100,"gender":"male","job":"取经"&#125;user_info_dict["job"] = "取经|偷桃"print(user_info_dict)print("%s的年龄是：%d，性别：%s，工作内容：%s"%(user_info_dict["name"],user_info_dict["age"],user_info_dict["gender"],user_info_dict["job"])) 结果： 12&#123;'name': '悟空', 'age': 100, 'gender': 'male', 'job': '取经|偷桃'&#125;悟空的年龄是：100，性别：male，工作内容：取经|偷桃 实例8: 123#key不能相同,会默认后面的键值user_info_dict = &#123;"name":"悟空","age":100,"gender":"male","job":"取经","job":"偷桃"&#125;print(user_info_dict) 结果： 1&#123;'name': '悟空', 'age': 100, 'gender': 'male', 'job': '偷桃'&#125; 实例9: 123#添加键值对user_info_dict["tel"] = "13812345567"print(user_info_dict) 结果： 1&#123;'name': '悟空', 'age': 100, 'gender': 'male', 'job': '偷桃', 'tel': '13812345567'&#125; 字典的内置方法 dict.get(key, default=None) 定义： Python 字典(Dictionary) get() 函数返回指定键的值，如果值不在字典中返回默认值。 123451. 参数 1. key -- 字典中要查找的键。 2. default -- 如果指定键的值不存在时，返回该默认值值。2. 返回值： 返回指定键的值，如果值不在字典中返回默认值None 实例10: 1234dict = &#123;'Name': 'Runoob', 'Age': 27&#125;print ("Age 值为 : %s" % dict.get('Age'))print ("Sex 值为 : %s" % dict.get('Sex', "NA")) 结果： 12Age 值为 : 27Sex 值为 : NA dict.keys() 定义：Python 字典(Dictionary) keys() 函数以列表返回一个字典所有的键。 12341. 参数 NA2. 返回值： 返回一个字典所有的键 实例11: 12dict = &#123;'Name': 'Zara', 'Age': 7&#125;print ("Value : %s" % dict.keys()) 结果： 1Value : ['Name', 'Age'] dict.values() 定义：Python 字典(Dictionary) values() 函数以列表返回字典中的所有值。 12341. 参数 NA2. 返回值 返回字典中所有值 实例12： 123dict = &#123;'Name': 'Zara', 'Age': 7&#125;print ("Value : %s" % dict.values()) 结果： 1Value : ['Zara', 7] dict.items() 定义：Python 字典(Dictionary) items() 函数以列表返回可遍历的(键, 值) 元组数组。 12341. 参数 NA2. 返回值 返回可遍历的（键，值）元组数组 实例13： 1234567dict = &#123;'Google': 'www.google.com', 'Runoob': 'www.runoob.com', 'taobao': 'www.taobao.com'&#125; print ("字典值 : %s" % dict.items()) # 遍历字典列表for key,values in dict.items(): print (key,values) 结果： 1234字典值 : [('Google', 'www.google.com'), ('taobao', 'www.taobao.com'), ('Runoob', 'www.runoob.com')]Google www.google.comtaobao www.taobao.comRunoob www.runoob.com dict.clear() 定义：Python 字典(Dictionary) clear() 函数用于删除字典内所有元素。 12341. 参数 NA2. 返回值 该函数没有任何返回值 实例14： 12345dict = &#123;'Name': 'Zara', 'Age': 7&#125;;print ("Start Len : %d" % len(dict))dict.clear()print ("End Len : %d" % len(dict)) 结果： 12Start Len : 2End Len : 0 集合Set 无序存储不同数据类型，不重复元素的序列 实例15： 123456#集合对列表去重student_list = ["zhansan","lisi","wangwu",'zhangsan','lisi']student_set = set(student_list)print(type(student_set))print(len(student_set))print(student_set) 结果： 123&lt;class 'set'&gt;4&#123;'zhansan', 'zhangsan', 'wangwu', 'lisi'&#125; 创建空集合 实例16： 123#创建一个空集合none_dict = &#123;&#125;#注意这是创建一个空字典none_set = set() #空集合 结果： 12&#123;&#125;set() 通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果： 实例17： 1234#add添加元素到集合name_set = &#123;"zhansan","lisi"&#125;name_set.add("wangwu")print(name_set) 结果： 1&#123;'zhansan', 'wangwu', 'lisi'&#125; 使用update（序列）方法将一个序列中的元素添加到集合中，同时对元素去重 实例18： 123#update(序列)name_set.update(["悟空","八戒"],["张飞","李逵"])print(name_set) 结果： 1&#123;'悟空', '李逵', 'wangwu', 'zhansan', '八戒', '张飞', 'lisi'&#125; remove（） 和 discard（） 以及pop（）的区别，都是删除的指令 实例19： 123456789101112131415161718name_set.update(["悟空","八戒"],["张飞","李逵"])print(name_set)#remove 删除元素name_set.remove("悟空")print(name_set)#dicard(元素),删除一个不存在的元素，不会报错name_set.discard("西游记")#pop()随机删除集合中的某个元素，并返回被删除的元素print(name_set)name = name_set.pop()print(name_set)# print(name)#使用remove删除一个不存在的元素，会报错name_set.remove("西游记") 结果： 123456789101112131415&#123;'悟空', '李逵', 'wangwu', 'zhansan', '八戒', '张飞', 'lisi'&#125;&#123;'李逵', 'wangwu', 'zhansan', '八戒', '张飞', 'lisi'&#125;&#123;'李逵', 'wangwu', 'zhansan', '八戒', '张飞', 'lisi'&#125;&#123;'wangwu', 'zhansan', '八戒', '张飞', 'lisi'&#125;wangwu---------------------------------------------------------------------------KeyError Traceback (most recent call last)&lt;ipython-input-31-c5efead19a78&gt; in &lt;module&gt;() 13 14 #使用remove删除一个不存在的元素，会报错---&gt; 15 name_set.remove("西游记") 16 17 KeyError: '西游记' 集合操作 交集intersection（&amp;） 并集union(|) 差集difference(-) 对称差集symmetric_difference(^) 实例20： 12345678910111213141516171819202122232425#交集num_set1 = &#123;1,2,4,7&#125;num_set2 = &#123;2,5,8,9&#125;inter_set1 = num_set1 &amp; num_set2inter_set2 = num_set1.intersection(num_set2)print(inter_set1)print(inter_set2)#并集union_set1 = num_set1 | num_set2union_set2 = num_set1.union(num_set2)print(union_set1)print(union_set2)#差集(set1中除去并集所剩下的集合)diff_set1 = num_set1 - num_set2diff_set2 = num_set1.difference(num_set2)print(diff_set1)print(diff_set2)#对称差集（set1和set2分别除去交集后再并集）sym_diff_set1 = num_set1 ^ num_set2sym_diff_set2 = num_set1.symmetric_difference(num_set2)print(sym_diff_set1)print(sym_diff_set2) 结果： 12345678&#123;2&#125;&#123;2&#125;&#123;1, 2, 4, 5, 7, 8, 9&#125;&#123;1, 2, 4, 5, 7, 8, 9&#125;&#123;1, 4, 7&#125;&#123;1, 4, 7&#125;&#123;1, 4, 5, 7, 8, 9&#125;&#123;1, 4, 5, 7, 8, 9&#125; 字符串常用内置方法字符串相关链接：字符串 str.find(str, beg=0, end=len(string)) 定义：Python find() 方法检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果包含子字符串返回开始的索引值，否则返回-1。 1234561.参数： str -- 指定检索的字符串 beg -- 开始索引，默认为0。 end -- 结束索引，默认为字符串的长度。2.返回值 如果包含子字符串返回开始的索引值，否则返回-1。 实例21： 1234567891011#findline = "hello world hello python"#hello第一次出现的脚标print(line.find("hello"))#指定查找的起始脚标print(line.find("hello",6))#不存在的子字符串返回-1print(line.find("java")) 结果： 123012-1 str.count(sub, start= 0,end=len(string)) 定义：Python count() 方法用于统计字符串里某个字符出现的次数。可选参数为在字符串搜索的开始与结束位置。 1234561.参数： sub -- 搜索的子字符串 start -- 字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为0。 end -- 字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个位置。2.返回值 该方法返回子字符串在字符串中出现的次数。 实例22： 123456str = "this is string example....wow!!!" sub = "i"print ("str.count(sub, 4, 40) : ", str.count(sub, 4, 40))sub = "wow"print ("str.count(sub) : ", str.count(sub)) 结果： 12str.count(sub, 4, 40) : 2str.count(sub) : 1 str.replace(old, new[, max]) 定义：Python replace() 方法把字符串中的old（旧字符串） 替换成new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。 1234561.参数： old -- 将被替换的子字符串。 new -- 新字符串，用于替换old子字符串。 max -- 可选字符串, 替换不超过 max 次2.返回值 返回字符串中的old（旧字符串）替换成new(新字符串)后生成的新字符串，如果指定第三个参数max，则替换不超过max 次。 实例23： 123str = "this is string example....wow!!! this is really string"print (str.replace("is", "was"))print (str.replace("is", "was", 3)) 结果： 12thwas was string example....wow!!! thwas was really stringthwas was string example....wow!!! thwas is really string str.split(str=””, num=string.count(str)) 定义：Python split()通过指定分隔符对字符串进行切片，如果参数num有指定值，则仅分隔num 个子字符串 123451.参数： str -- 分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。 num -- 分割次数。2.返回值 返回分割后的字符串列表。 实例24： 123str = "Line1-abcdef \nLine2-abc \nLine4-abcd"print (str.split( ))print (str.split(' ', 1 )) 结果： 12['Line1-abcdef', 'Line2-abc', 'Line4-abcd']['Line1-abcdef', '\nLine2-abc \nLine4-abcd'] startswith 定义：Python startswith()方法用于检查字符串是否是以指定子字符串开头，如果是则返回 True，否则返回 False。如果参数 beg 和 end 指定值，则在指定范围内检查。 1234561.参数： str -- 检测的字符串。 strbeg -- 可选参数用于设置字符串检测的起始位置。 strend -- 可选参数用于设置字符串检测的结束位置。2.返回值 如果检测到字符串则返回True，否则返回False。 实例25： 1234str = "this is string example....wow!!!"print (str.startswith( 'this' ))print (str.startswith( 'is', 2, 4 ))print (str.startswith( 'this', 2, 4 )) 结果： 123TrueTrueFalse str.endswith(suffix[, start[, end]]) 定义：Python endswith()方法用于判断字符串是否以指定后缀结尾，如果以指定后缀结尾返回True，否则返回False。可选参数”start”与”end”为检索字符串的开始与结束位置。 1234561.参数： suffix -- 该参数可以是一个字符串或者是一个元素。 start -- 字符串中的开始位置。 end -- 字符中结束位置。2.返回值 如果字符串含有指定的后缀返回True，否则返回False。 实例26： 123456789str = "this is string example....wow!!!"suffix = "wow!!!"print (str.endswith(suffix))print (str.endswith(suffix,20))suffix = "is"print (str.endswith(suffix, 2, 4))print (str.endswith(suffix, 2, 6)) 结果： 1234TrueTrueTrueFalse startswith、endswith的应用场景12345#需要找出2018年以log结尾的文件files = ["20171201.txt","20171201.log","20180101.txt","20180101.log"]for file in files: if file.startswith("2018") and file.endswith("log"): print("2018年待处理日志：%s"%file) 结果： 12018年待处理日志：20180101.log str.upper() 定义：Python upper()方法将字符串中的小写字母转为大写字母。 12341.参数： NA2.返回值 返回小写字母转为大写字母的字符串。 实例27： 123str = "this is string example....wow!!!"print ("str.upper() : ", str.upper()) 结果： 1str.upper() : THIS IS STRING EXAMPLE....WOW!!! str.lower() 定义：Python lower()方法转换字符串中所有大写字符为小写。 12341.参数： NA2.返回值 返回大写字母转为小写字母的字符串。 实例28： 123str = "THIS IS STRING EXAMPLE....WOW!!!"print (str.lower()) 结果： 1this is string example....wow!!!]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>元组</tag>
        <tag>字典</tag>
        <tag>字符串内置方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python(二)]]></title>
    <url>%2F2018%2F07%2F08%2FPython-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[循环语句（三大执行流程之一，还包括选择执行，顺序执行）下面是程序流程图： while循环 语法格式 12while 判断条件： 条件满足，执行语句 程序样例1: 1234num = 1while num &lt;= 10: #打印1-10的数字 print(num) num += 1 结果: 1234567891012345678910 执行流程 应用场景 对于满足某种条件，调用实现相同功能的代码 循环嵌套语法结构： 1234while 判断条件： 调价你满足，执行语句 while 嵌套判断条件： 条件满足，执行语句 程序2.打印到三角形: 1234567891011i = 0 #第几行，行号# 4行的到三角形while i &lt; 4: print(" "* i,end="")#打印每行开头的空格 j = 0 #控制*个数 #进行while的嵌套 while j &lt; 7-i*2: print("*",end="") # end表示循环内不空行 j +=1 print("") #实现每一行打印完换行 i = i+1 #对i进行自加，如果不自加则会进行无限循环 结果： 1234******* ***** *** * 程序3.打印正三角形: 123456789i = 4 #4行的正三角形，定义行数while i &gt; 0: i -= 1 print(" "*i,end="")#打印开头空格 j = 0 while j &lt; 7-i*2: print("*",end="") j +=1 print("") 结果: 1234 * *** ************ 程序4.打印沙漏: 123456789101112131415161718m = 7 #控制总行数i = 0 #外层循环的次数，行号h = 0 #空格的个数middle = m // 2 #中间位置while i &lt; m: if i &lt;= middle: h = i #倒正三角形的时候，空格个数等于行号 else: h -= 1 n = m-h*2 #打印一行开头的空格和星号 print(" "*h,end="")#打印开头空格 j = 0 while j &lt; n: print("*",end="") j +=1 print("") i += 1 如果有不明白的地方，可以通过Pycharm的debug模式进行一步步看结果的变化，i，h随时循环的进行，是变化的。 结果： 1234567******* ***** *** * *** ************ while的循环中的break和continue break语法结构： 12while 条件： break #整个循环结束 while循环嵌套中使用break： 1234while 条件： 代码 while 条件： break #只结束内层整个循环 程序5：break跳出循环 12345678#当时i= 10的时候，跳出break循环（并且不能打印10）i = 1while i &lt;= 20: if i % 2 == 0: if i % 10 == 0: break print(i) i += 1 结果: 12342468 continue语法结构: 1234while 条件： if 条件： continue #本次循环结束，后边的代码语句不执行 代码语句 程序6:continue 12345678#当i=10的时候，不执行print打印，直接继续进入下一个循环循环i = 1while i &lt;= 20: i += 1 if i % 2 == 0: if i % 10 == 0: continue print(i) 结果: 12345678246812141618 for 循环 语法结构: 12for 临时变量 in 序列： #这里的序列是一个迭代器（iterator） 序列中存在待处理元素则进入循环体执行代码 执行流程 for 循环遍历，序列中所有的元素，并执行对应的语句。 程序7:for 循环 12for i in range(0,10): print(i) 结果: 123456789100123456789 for 循环的break和continue break语法结构: 12for 变量 in 序列： break #整个循环结束 程序8:break跳出循环for 12345678#当 i = 4的时候，j能取到3，直接跳出循环，继续外循环for i in range(1,5): ##range（起始，结束，步长） for j in range(0,i): if j == 2: break print("*",end="") print("") print(i) 结果: 12345678*1**2**3**4 continue语法结构: 123for 变量 in 序列： if 条件： continue #本次循环结束，后边的代码语句不执行，但仍然继续循环 程序9:continue继续循环 1234567for i in range(1,5): for j in range(0,i): if j == 2: continue print("*",end="") print("") print(i) 结果: 12345678*1**2**3***4 字符串类型变量定义1234s = 'hello's = "hello"##如果字符串里面需要有单引号的情况，可以以下情况s ="'name'" 组成字符串的方式 使用”+”号将两个字符串连接成一个新的字符串 1print('hello'+'world') 使用字符串格式化符号 12345#将int类型转换为字符串类型num = 123num_str = str(num)print(type(num))print(type(num_str)) 结果为: 12&lt;class 'int'&gt;&lt;class 'str'&gt; 下标 通过下标获取指定位置的字符：string_name[index] 12345#符号空格都占一个字符name = 'zhangsan,20'print(name[0])#-1是指最后一个位置print(name[-1]) 结果: 12z0 切片 语法:string_name[起始：结束：步长] 程序10：字符串的切片: 1234567891011line = "zhangsan,20"name = line[0:8]print(name)age1 = line[9:] #不写默认到最后一位age2 = line[9:11]print(age1)print(age2)#2指步长，相隔一个取s = "abcde"print(s[0::2]) 结果: 1234zhangsan2020ace 列表的定义和基础属性 可以储存相同或者不同类型数据的集合 1list = [a,'123',456] 顺序储存，可通过下标获取内部元素 12345678list = [a,'123',456]print(list[0])print(list[2])##结果a456 内容可变，可通过下标修改元素值 12345list = [a,'123',456]list[2] = 'zhangsan'#结果[a,'123','zhangsan'] 使用循环遍历列表 12345678910111213info_list = ["zhangsan",20,180.5]#while遍历while i &lt; len(info_list): print(info_list[i]) i += 1#for遍历for i in range(0,len(info_list)): print(info_list[i])#简便方法for item in info_list: print(item) 结果: 123456zhangsan20180.5zhangsan20180.5 循环的嵌套 12345678infos_list = [[&quot;zhangsan&quot;,20,180.5],[&quot;lisi&quot;,21,170],[&quot;wangwu&quot;,25,190]]print(infos_list[0][0])print(infos_list[1][0])print(&apos;\n&apos;) #空一行for lst in infos_list: print(lst) for item in lst: print(item) 结果: 123456789101112131415zhangsanlisi['zhangsan', 20, 180.5]zhangsan20180.5['lisi', 21, 170]lisi21170['wangwu', 25, 190]wangwu25190 列表的相关内置函数 append()/insert()添加元素 12345678910#append列表末尾添加元素infos_list = [["zhangsan",20,180.5],["lisi",21,170],["wangwu",25,190]]infos_list.append(["xiaobai",30,175])print(infos_list)print('\n')#insert向列表指定位置添加元素new_info = ["孙悟空",18,160]new_info.insert(1,50) #1指列表中的1号位置print(new_info) 结果： 1234[['zhangsan', 20, 180.5], ['lisi', 21, 170], ['wangwu', 25, 190], ['xiaobai', 30, 175]]['孙悟空', 50, 18, 160] “+”组合两个列表生成新的列表,append(),extend() 123456789101112#+拼接两个列表name_list1 = ["zhangsan"]name_list2 = ["lisi","wangwu"]name_list3 = name_list1 + name_list2print(name_list3)#extend 向一个列表中添加另外一个列表的元素name_list1.extend(name_list2)print(name_list1)name_list1.append(name_list2)print(name_list1) 结果： 123['zhangsan', 'lisi', 'wangwu']['zhangsan', 'lisi', 'wangwu']['zhangsan', 'lisi', 'wangwu', ['lisi', 'wangwu']] del()/pop()/remove()删除元素 123456#删除列表元素group = ["唐僧","悟空","八戒","白龙马"]del group[1]group.remove("八戒")group.pop(0)print(group) 结果： 1['白龙马'] 切片（如同上字符串切片语法相同，只不过单个字符变为列表中的元素） in/not in 判断元素在列表中是否存在 12345group = ['白龙马']if "唐僧" in group: print("师傅还在")else: print("师傅没了") 结果： 1师傅没了 sort()列表内元素重排序 123456789#sort()num_list = [5,2,6,1]# num_list.sort()#升序num_list.sort(reverse=True)print(num_list)#reverse()将列表内容 倒置group = [1,3,4,5,6,7,8]group.reverse()print(group) 结果： 12[6, 5, 2, 1][8, 7, 6, 5, 4, 3, 1] count()统计列表内指定元素个数 12group = [1,2,3,4,5,4,3,2,2,2,3]print(group.count(4)) 结果： 12 附加：条件表达式和列表推导式（能够缩减代码的运行时间） 123456789101112#条件表达式import mathdef get_log(x): log_v = math.log(x) if x&gt;0 else float('nan') return log_vprint (get_log(5))print (get_log(-1))print('======')#列表推导式l1 = [i for i in range(1,10) if i%2 ==0]print(l1) 结果: 12341.6094379124341003nan======[2, 4, 6, 8]]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
        <tag>循环结构</tag>
        <tag>列表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python(一)]]></title>
    <url>%2F2018%2F07%2F07%2Fpython-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Python概述 一种面向对象的解释型计算机程序设计语言 具有丰富且强大的内置库和第三方库 语法简洁灵活 开源、跨平台 应用场景： 数据分析 人工智能 网络爬虫 自动化运维 ······· python的基础语法 交互模式 上图是在cmd环境中的运行模式 开发流程 创建以.py结尾的python文件 在python文件中输入打印’hello world’的代码（这里的标点可以是单引号或双引号，注意的是要求半角符号[英文输入法情况]，不是全角[中文输入法情况]） 运行编写完的python代码文件 使用Pycharm创建Python项目 如果做数据可视化测试也可以使用anaconda中的notebook 注释 使用注释的原因希望通过自己的语言来描述一段代码的实现逻辑和功能，方便理解代码，易于维护 实例1： 12#打印hello worldprint('hello world') 单行注释以#开头，只注释一行，多行注释需要在需要注释的内容开头分别添加 (诀窍，把多行代码选中，ctrl+/ 可以直接多行注释#) 实例2： 123##打印hello world#习惯输入空格，不要让代码挨的太近，不便于观察print ('hello world') 多行注释‘’’注释内容’’’或者”””注释内容”””，可以对多行内容整体进行注释 实例3： 123456789"""注释内容"""'''注释内容'''#以上两种方法都可以对多行进行注释 注释的作用描述一段代码的实现逻辑和功能，增强代码可读性，易于维护 注意注释在代码执行过程中不会被执行，注释数量没有限制 变量变量的定义 在python中，变量指向各种类型值的名字，当用到这个类型的值时，直接使用变量即可，不需要再写具体的值 格式：变量名 = 数值/字符串 实例4： 123456789a = 100b = 200 c = a + bprint(c)m = 'hello'n = 'world'q = m + n print(q) 结果： 123300'hello world' 变量的类型不需要显示指定，python解释器会自动判断数据类型，可以把任意数据类型赋值给变量（意思就是说，不用指定变量的类型，python解释器会自动判断） 变量名称命名简介明了，见名知意（意思就是说取变量名的时候最好用英文来当，最好是有实际意义的，这样阅读代码的时候可以知道变量的含义，如果需要，可以加以注释) 使用type(变量)查看变量类型 实例5： 123456789101112#打印个人信息name = 'zhangsan' #名字--字符串high = 180 #身高--数值型weight = 20.0 #体重--数值型#输入数值并且输出类型print(name)print(type(name))print(high)print(type(high))print(weight)print(type(weight)) 结果： 12345678zhangsan&lt;class 'str'&gt;180&lt;class 'int'&gt;20.0&lt;class 'float'&gt;##更多的数据类型，见下图 数据类型 input输入、print输出Input()用于在程序中执行过程中接收用户输入的内容，默认接收的输入内容为字符串类型。 实例6： 123456card_id = input("请输入卡号:")pwd = input("请输入密码:")print(card_id)print(type(card_id))print(pwd) 结果： 12345请输入卡号:123请输入密码:123123&lt;class 'str'&gt;123 print()用于在程序执行过程中输入内容 直接输出内容 输出单个和多个变量 格式化输入 格式化输出应用示例:print(‘你输入的名字是：%s’%name) 或者print(‘你输入的名字是{}。’.format(name)) 实例7： 123name = input()print('你输入的名字是：%s'%name)print('你输入的名字是：&#123;&#125;。'.format(name)) 结果： 12345zhangsan 你输入的名字是：zhangsan 你输入的名字是：zhangsan 。#常用的格式符号见下图 注意：常用的格式化符号有%d，%s，%f 实例8： 12345678#多个变量同时输出card_id = "234567"pwd = 123#\n是换行符print("您输入的卡号是：%s，\n您输入的密码是：%d" %(card_id,pwd))print('====分割线====')print('您输入的卡号是：&#123;&#125;,\n您输入的密码是：&#123;&#125;'.format(card_id,pwd)) 结果： 12345您输入的卡号是：234567，您输入的密码是：123====分割线====您输入的卡号是：234567,您输入的密码是：123 实例9： 1234#格式化输出浮点数,并指定精度height = 180.35234print("您的身高是：%.2f cm" %height)print('您的身高是：&#123;:.2f&#125; cm'.format(height)) 结果： 12您的身高是：180.35 cm您的身高是：180.35 cm 实例10： 1234#格式化输出时，打印%，要使用%%表示是字符串而不是转换说明符p = 99.99321print("您战胜了全国%.2f%%的用户" %p)print('您战胜了全国&#123;:.2f&#125;的用户'.format(p)) 结果： 12您战胜了全国99.99%的用户您战胜了全国99.99的用户 实例11： 123#print无换行输出print("hello",end="")print("python") 结果： 1hellopython 实例12： 1234#输出换行符print("中国\n北京")#转义字符\print("中国\\n北京") 结果： 123中国北京中国\n北京 类型转换不同的类型之间进行转换 实例13： 123456789101112a = 123print(a)print(type(a))print('将int类型转换成字符型：')b = str(a)print(b)print(type(b))print('将int类型装换成浮点型')c = float(a)print(c)print(type(c)) 结果： 12345678123&lt;class 'int'&gt;将int类型转换成字符型：123&lt;class 'str'&gt;将int类型装换成浮点型123.0&lt;class 'float'&gt; 实例14： 12345#eval(str)把字符串自动转换成合适的数据类型a1= eval("123")a2 = eval("3.14")print(type(a1))print(type(a2)) 结果： 12&lt;class 'int'&gt;&lt;class 'float'&gt; 标识符、命名规则、关键字标识符 在python程序开发过程中，自定义的一些符号、名称 由字母、数字、下划线（_）组成，不能以数字开头 标识符区分大小写 实例15： 1234#不能以数字开头2student = 'zhangsan'print(2student)#报错语法错误 结果： 1234 File "&lt;ipython-input-15-978c7772c00c&gt;", line 2 2student = 'zhangsan' ^SyntaxError: invalid syntax 实例16： 12345#python解释器是可以区分大小写的student_name = 'zhangsan'Student_name = 'lisi'print(student_name)print(Student_name) 结果： 12zhangsanlisi 命名规则 见名如意，如name 驼峰命名法，如类名(UserInfo)、异常名(ValueError)等 小写字符+下划线，如变量名(user_name)、函数名(get_name) 不能使用关键字 关键字 在python内部具有特殊功能的标识符 通过keyword模块的kwlist函数查看 实例17： 123import keyword#打印py3的关键字，命名是不能使用的print(keyword.kwlist) 结果： 1['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 运算符和优先级运算符 运算符优先级! 项目–计算器实例18： 123456789101112131415161718192021num1 = input("请输入第一个数字：")operator = input("请输入运算符：")num2 = input("请输入第二个数字：")num_1 = int(num1)num_2 = int(num2)if operator == "+": result = num_1 + num_2 print("计算结果：&#123;&#125;".format(result))elif operator == "%": result = num_1 % num_2 print("计算结果：&#123;&#125;".format(result))elif operator == "**": result = num_1 ** num_2 print("计算结果：&#123;&#125;".format(result))elif operator == "//": result = num_1 // num_2 print("计算结果：&#123;&#125;".format(result))else: print("正在开发..")]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础语法</tag>
        <tag>命名规则</tag>
        <tag>顺序语句</tag>
      </tags>
  </entry>
</search>
